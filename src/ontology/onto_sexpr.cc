#include "ontology/onto_sexpr.h"
#include "ontology/onto_keywords.h"
#include "seq/pkeywords.h"
#include "guile/newick-type.h"

Termx::Termx()
  : init_scm (SCM_BOOL_F),
    model_scm (SCM_BOOL_F),
    tree_db_scm (SCM_BOOL_F),
    knowledge_scm (SCM_BOOL_F),
    knowledge_func_scm (SCM_BOOL_F),
    var_counts(pscores),
    dummy_alph(),
    matrix_set(dummy_alph),
    got_counts(false)
{ }

Termx::Termx (SCM scm)
  : init_scm (SCM_BOOL_F),
    model_scm (SCM_BOOL_F),
    tree_db_scm (SCM_BOOL_F),
    knowledge_scm (SCM_BOOL_F),
    knowledge_func_scm (SCM_BOOL_F),
    var_counts(pscores),
    dummy_alph(),
    matrix_set(dummy_alph),
    got_counts(false)
{
  Termx_builder::init_termx (*this, scm);
}

Termx::Termx (const SExpr& sexpr)
  : init_scm (SCM_BOOL_F),
    model_scm (SCM_BOOL_F),
    tree_db_scm (SCM_BOOL_F),
    knowledge_scm (SCM_BOOL_F),
    knowledge_func_scm (SCM_BOOL_F),
    var_counts(pscores),
    dummy_alph(),
    matrix_set(dummy_alph),
    got_counts(false)
{
  Termx_builder::init_termx (*this, (SExpr&) sexpr);
}

Termx::~Termx()
{
  unprotect (init_scm);
  unprotect (model_scm);
  unprotect (tree_db_scm);
  unprotect (knowledge_scm);
  unprotect (knowledge_func_scm);
}

void Termx::unprotect (SCM scm)
{
  if (SCM_NFALSEP(scm))
    scm_gc_unprotect_object (scm);
}

EM_matrix_base& Termx::rate_matrix()
{
  if (matrix_set.chain.size() != 1 || matrix_set.chain[0].matrix == NULL)
    THROWEXPR ("Oops -- no rate matrix in Termx");
  return *matrix_set.chain[0].matrix;
}

ECFG_chain& Termx::chain()
{
  if (matrix_set.chain.size() != 1)
    THROWEXPR ("Oops -- no chain in Termx");
  return matrix_set.chain[0];
}

const Alphabet& Termx::default_alphabet()
{
  if (alph_list.empty())
    THROWEXPR ("Oops -- no alphabet in Termx");
  return alph_list.front();
}

void Termx::eval_funcs()
{
  matrix_set.eval_funcs (pscores);
  stats = Update_statistics (rate_matrix().number_of_states());
}

void Termx_builder::init_termx (Termx& term, SExpr& wrapper_sexpr)
{
  SExpr& termx_sexpr = wrapper_sexpr.find_or_die (TERMX_TERMX);
  const Ass_map ass_map (termx_sexpr, 1);
  init_termx (term, ass_map);
}

void Termx_builder::init_termx (Termx& term, SCM termx_scm)
{
  THROWASSERT (SCM_NFALSEP(scm_list_p(termx_scm)));
  // TODO: check that car of list is either "termx" string or termx symbol
  SCM args_scm = scm_cdr (termx_scm);
  const Ass_map ass_map (args_scm);
  init_termx (term, ass_map);
}

void Termx_builder::init_termx (Termx& term, const Ass_map& ass_map)
{
  init_termx_member_scm (term.init_scm, ass_map, TERMX_INIT_SCM);
  init_termx_member_scm (term.model_scm, ass_map, TERMX_MODEL_SCM);
  init_termx_member_scm (term.tree_db_scm, ass_map, TERMX_TREE_DB_SCM);
  init_termx_member_scm (term.knowledge_scm, ass_map, TERMX_KNOWLEDGE_SCM);

  if (!scm_is_false (term.init_scm))
    (void) scm_primitive_eval (term.init_scm);

  SExpr params_sexpr = ass_map.sexpr_parent_or_empty_list (TERMX_PARAMS);
  init_termx_params (term, params_sexpr);

  SExpr model_sexpr;
  if (!scm_is_false (term.model_scm))
    {
      // if model is generated by Scheme, ensure it does not encode parameter values
      model_sexpr = scm_to_sexpr (scm_primitive_eval (term.model_scm));
      init_termx_model (term, model_sexpr);
      if (term.chain().type != Parametric)
	THROWEXPR(TERMX_MODEL_SCM << " function must return (" << TERMX_MODEL << " (" << EG_CHAIN << " (" << EG_CHAIN_POLICY << " " << EG_PARAMETRIC << ") ...) ...)");
    }
  else
    {
      model_sexpr = ass_map.sexpr_values_list (TERMX_MODEL);
      init_termx_model (term, model_sexpr);
    }

  term.knowledge_func_scm = scm_primitive_eval (term.knowledge_scm);
  if (SCM_NFALSEP(term.knowledge_func_scm))
    scm_gc_protect_object (term.knowledge_func_scm);
}

void Termx_builder::init_termx_member_scm (SCM& member_scm, const Ass_map& parent_ass_map, const char* tag)
{
  member_scm = parent_ass_map.scm_value_or_false (tag);
  if (SCM_NFALSEP(member_scm))
    scm_gc_protect_object (member_scm);
}

void Termx_builder::init_termx_params (Termx& term, SExpr& model_sexpr)
{
  // initialise PScores
  init_pgroups_and_rates (term.pscores, term.sym2pvar, model_sexpr, &term.mutable_pgroups);
  // initialise PCounts
  term.pcounts = PCounts (term.pscores);  // sensible default
  init_pseudocounts (term.pcounts, term.pscores, term.sym2pvar, model_sexpr);
  term.var_counts = PCounts (term.pscores);
}

void Termx_builder::init_termx_model (Termx& term, SExpr& model_sexpr)
{
  // initialise alphabet(s)
  const vector<SExpr*> alph_sexprs = model_sexpr.find_all (PK_ALPHABET);
  if (alph_sexprs.size() == 0)
    THROWEXPR ("You need at least one alphabet");
  for_const_contents (vector<SExpr*>, alph_sexprs, alph_sexpr)
    {
      term.alph_list.push_back (term.dummy_alph);
      Alphabet& alph (term.alph_list.back());
      init_alphabet (alph, **alph_sexpr, true);
      term.alph_dict.add (alph);
    }
  // initialise chain
  init_chain (term.matrix_set, term.alph_dict, term.default_alphabet(), term.term2chain, term.sym2pvar, model_sexpr.find_or_die (EG_CHAIN), DEFAULT_TIMEPOINT_RES, true);
}

void Termx_builder::termx2stream (ostream& out, Termx& term)
{
  out << '(' << TERMX_TERMX << '\n';
  termx_member_scm2stream (out, term.init_scm, TERMX_INIT_SCM);

  if (!scm_is_false (term.model_scm))
    termx_member_scm2stream (out, term.model_scm, TERMX_MODEL_SCM);
  else
    termx_model2stream (out, term);

  termx_member_scm2stream (out, term.tree_db_scm, TERMX_TREE_DB_SCM);
  termx_member_scm2stream (out, term.knowledge_scm, TERMX_KNOWLEDGE_SCM);

  termx_params2stream (out, term);

  out << ") ;; end " TERMX_TERMX "\n";
}

void Termx_builder::termx_member_scm2stream (ostream& out, SCM& member_scm, const char* tag)
{
  if (!scm_is_false (member_scm))
    {
      sstring member_scm_str = scm_to_string (member_scm);
      out << " (" << tag << " " << member_scm_str << ")\n";
    }
}

void Termx_builder::termx_model2stream (ostream& out, Termx& term)
{
  out << " (" << TERMX_MODEL << '\n';
  chain2stream (out, term.pscores, ((Termx&)term).chain(), term.alph_dict, term.default_alphabet(), term.got_counts ? &term.stats : NULL);
  for_const_contents (list<Alphabet>, term.alph_list, alph)
    alphabet2stream (out, *alph);
  out << " ) ;; end " TERMX_MODEL "\n";
}

void Termx_builder::termx_params2stream (ostream& out, Termx& term)
{
  out << "\n (" << TERMX_PARAMS << '\n';
  pscores2stream (out, term.pscores, term.mutable_pgroups, &term.var_counts);
  pcounts2stream (out, term.pcounts, EG_PSEUDOCOUNTS, (const PCounts*) 0, true, false);
  if (term.got_counts)
    pcounts2stream (out, term.var_counts, EG_EXPECTED_COUNTS, &term.pcounts, true, true);
  out << " ) ;; end " TERMX_PARAMS "\n";
}

SCM Termx_family_visitor::map_reduce_scm()
{
  SCM tree_db_list_scm = scm_primitive_eval (termx.tree_db_scm);
  if (SCM_FALSEP(scm_list_p(tree_db_list_scm)))
    THROWEXPR (TERMX_TREE_DB_SCM " function must return a list");

  CTAG(5,TERMX) << "Beginning iteration over families\n";
  scm_t_bits accumulator = zero();

  current_family_index = 0;
  while (!scm_is_null(tree_db_list_scm))
    {
      CTAG(5,TERMX) << "Visiting family #" << (current_family_index + 1) << "\n";

      SCM tree_db_entry_scm = scm_car (tree_db_list_scm);
      if (SCM_FALSEP(scm_list_p(tree_db_entry_scm)) || scm_to_uintmax(scm_length(tree_db_entry_scm)) != 2)
	THROWEXPR (TERMX_TREE_DB_SCM " function must return a list");

      current_name_scm = scm_car (tree_db_entry_scm);
      current_newick_scm = scm_cadr (tree_db_entry_scm);

      if (!scm_is_string(current_name_scm))
	CLOGERR << TERMX_TREE_DB_SCM " function must return a list of (name newick) lists, where the name is a string\n";

      current_name = scm_to_string_unquoted (current_name_scm);
      current_tree = newick_cast_from_scm (current_newick_scm);

      CTAG(5,TERMX) << "Family #" << (current_family_index + 1) << ": " << current_name << "\n";

      init_current();
      accumulator = reduce (accumulator);

      scm_remember_upto_here_2 (current_name_scm, current_newick_scm);

      tree_db_list_scm = scm_cdr (tree_db_list_scm);
      ++current_family_index;
    }

  CTAG(5,TERMX) << "All families done; finalizing...\n";
  return finalize (accumulator);
}

void Termx_EM_visitor::initialize_current_colmat()
{
  map<sstring,Symbol_score_map> named_node_scores;
  // fill named_node_scores by calling knowledge function
  for (Phylogeny::Node n = 0; n < current_tree->nodes(); ++n)
    if (current_tree->node_name[n].size())
    {
      const sstring& node_name = current_tree->node_name[n];
      Symbol_score_map node_ssm;
      // loop over states, creating state tuples and calling knowledge function as follows:
      // (knowledge familyName geneName (term1 term2 ... hiddenState))
      for (int state = 0; state < termx.rate_matrix().number_of_states(); ++state)
	{
	  const bool knowledge_result_true = knowledge_func (n, state);
	  if (CTAGGING(3,TERMX))
	    CL << "(" TERMX_KNOWLEDGE_SCM " " << current_name << " " << node_name << " (" << state_tuple(state) << "))  =  " << (knowledge_result_true ? "#t" : "#f") << '\n';
	  const Score knowledge_result_score = knowledge_result_true ? ScoreOfProb1 : ScoreOfProb0;
	  node_ssm.insert (Symbol_score (state, knowledge_result_score));
	}

      // copy into named_node_scores
      named_node_scores[node_name] = node_ssm;
    }

  vector<const Symbol_score_map*> node_scores;
  const Symbol_score_map& wild_ssm = termx.rate_matrix().alphabet().wild_ssm;
  // fill node_scores by looking up named nodes in named_node_scores, and using wildcards for unnamed nodes
  for (Phylogeny::Node n = 0; n < current_tree->nodes(); ++n)
    if (current_tree->node_name[n].size())
      node_scores.push_back (&named_node_scores[current_tree->node_name[n]]);
    else
      node_scores.push_back (&wild_ssm);

  // initialise Column_matrix
  current_colmat.alloc (current_tree->nodes(), termx.rate_matrix().number_of_states());
  current_colmat.initialise (*current_tree, node_scores);
}

SCM termx_evidence (SCM termx_scm)
{
  Termx term (termx_scm);
  Termx_log_evidence log_ev (term);
  SCM log_ev_scm = log_ev.map_reduce_scm();
  return log_ev_scm;
}

SCM termx_prediction (SCM termx_scm)
{
  Termx term (termx_scm);
  Termx_prediction prediction (term);
  SCM prediction_scm = prediction.map_reduce_scm();
  return prediction_scm;
}

SCM termx_learn (SCM max_steps_scm, SCM termx_scm)
{
  Termx term (termx_scm);
  const int max_steps = scm_to_int (max_steps_scm);
  Termx_trainer trainer (term, max_steps);
  return trainer.final_scm();
}

void init_termx_primitives (void)
{
  scm_c_define_gsubr (GUILE_TERMX_EVIDENCE, 1, 0, 0, (SCM (*)()) termx_evidence);
  scm_c_define_gsubr (GUILE_TERMX_PREDICT, 1, 0, 0, (SCM (*)()) termx_prediction);
  scm_c_define_gsubr (GUILE_TERMX_LEARN, 2, 0, 0, (SCM (*)()) termx_learn);
}
