#!/usr/bin/perl -w

# pseudo-tag
my $no_tag = "<none>";

# the following subroutine returns a list of ["CTAG[GING]", LogLevel, [Tags]] tuples
sub ctags {
    my ($line) = @_;
    my @tags;
    while ($line =~ /(CLOG|CLOGGING|CTAG|CTAGGING)\s*\(\s*(\-?\s*\d+)\s*,?\s*([^\)]*?)\s*\)/g) {
	push @tags, [$1, $2, $3];
    }
    foreach my $tag (@tags) {
#	warn join (";", @$tag), ";    <--- $line";
	$$tag[2] = $$tag[2] eq "" ? [$no_tag] : [split /\s+/, $$tag[2]];
    }
#    if (@tags) { warn ">>> ", join ("\n   ", map("$$_[0]:$$_[1]:@{$$_[2]}:",@tags)), "\n"; }
    if (@tags == 0 && (/CTAG\b/ || /CLOG\b/)) { die "Missed CTAG\n", $line }
    return @tags;
}

# main program
my $prog = $0;
my $progdir;
my $progname;
if ($prog =~ /^(.*)\/([^\/]+)/) {
    ($progdir, $progname) = ($1, $2);
}

my $topdir;
if (@ARGV == 0) { $topdir = "$progdir/.." }
elsif (@ARGV == 1) { $topdir = shift }
else { die "Usage: $progname [<top-level directory>]" }

local *TOPDIR;
opendir TOPDIR, $topdir or die "Couldn't open $topdir: $!";
my @srcdir = grep !/^\./ && -d "$topdir/$_", readdir TOPDIR;
closedir TOPDIR;

my %src;
foreach my $srcdir (@srcdir) {
    my %srctag;
    
    my $srcpath = "$topdir/$srcdir";
    local *SRCDIR;
    opendir SRCDIR, $srcpath or die "Couldn't open $srcpath: $!";
    my @srcfile = grep !/^\./ && /\.(c|cc|C|cpp|c\+\+|h)$/ && -f "$srcpath/$_", readdir SRCDIR;
    closedir SRCDIR;
    
    local *SRCFILE;
    foreach my $srcfile (@srcfile) {
	next if $srcfile eq "logfile.h";  # skip the file where CTAG macros are defined
#	warn "$srcdir $srcfile";
	my %tag;
	
	my $srcfilepath = "$srcpath/$srcfile";
	local *SRCFILE;
	open SRCFILE, "<$srcfilepath" or die "Couldn't open $srcfilepath: $!";
	my $srcline = 0;
	while (<SRCFILE>) {
	    ++$srcline;
	    my @tags = ctags ($_);
	    if (@tags) { $tag{$srcline} = \@tags }
	}
	close SRCFILE;
	
	$srctag{$srcfile} = \%tag;
    }

    $src{$srcdir} = \%srctag;
#    warn "Skipping all source dirs except $srcdir"; last;
}

# convert list of CTAG lines to tag-indexed source file lookup
my %taginfo;
foreach my $srcdir (keys %src) {
    my $srcfileHash = $src{$srcdir};
#    warn "srcdir=$srcdir srcfiles=(", join (" ", keys %$srcfileHash), ")\n";
    foreach my $srcfile (keys %$srcfileHash) {
	my $srclineHash = $srcfileHash->{$srcfile};
#	warn "srcdir=$srcdir srcfile=$srcfile srclines=(", join (" ", keys %$srclineHash), ")";
	foreach my $srcline (keys %$srclineHash) {
	    foreach my $tagarray (@{$srclineHash->{$srcline}}) {
		my ($ctagstr, $loglevel, $tags) = @$tagarray;
#		warn "srcdir=$srcdir srcfile=$srcfile srcline\#$srcline=($ctagstr $loglevel (@$tags))";
		foreach my $tag (@$tags) {
		    $taginfo{$tag} = [] unless exists $taginfo{$tag};
		    push @{$taginfo{$tag}}, [$loglevel, $srcdir, $srcfile, $srcline];
		}
	    }
	}
    }
}
#warn "Tags: (", join (" ", keys %taginfo), ")\n";


# output
print "/* This file automatically generated by $progname. DO NOT EDIT */\n";
print "\n";
print "#ifndef LOGTAGS_INCLUDED\n";
print "#define LOGTAGS_INCLUDED\n";
print "\n";

my @tags = sort keys %taginfo;  # sort alphabetically by tag
my $maxtaglen = max (map (length($_), @tags));
my $maxsrcdirlen = max (map (length($_), keys %src));
my $maxsrcfilelen = max (map (length($_), map (keys(%$_), values %src)));

my $colwidth = 80;
my @realtags = grep ($_ ne $no_tag, @tags);
my $tagsperrow = max (int ($colwidth / ($maxtaglen + 1)), 1);
my $cols = int (@realtags / $tagsperrow);
++$cols if @realtags % $tagsperrow;

print "const char* all_log_tags = \"\\n";
for (my $i = 0; $i < $cols; ++$i) {
    for (my $j = $i; $j < @realtags; $j += $cols) {
	pprint ($realtags[$j], $maxtaglen + 1);
    }
    print "\\n";
}
print "\";\n";

print "const char* all_log_tag_info = \"\\n";
pprint ("Tag", $maxtaglen + 1, "Level", 6, "Module", $maxsrcdirlen + 1, "File#line\\n");
pprint ("---", $maxtaglen + 1, "-----", 6, "------", $maxsrcdirlen + 1, "---------\\n");
foreach my $tag (@tags) {
    my $outblock = [];
    my @instance = sort { $$b[0] <=> $$a[0] || $$a[1] cmp $$b[1] || $$a[2] cmp $$b[2] || $$a[3] <=> $$b[3] } @{$taginfo{$tag}};  # sort by decreasing log level, increasing source dir/file/line
#    warn "tag=$tag instances=(@instance)";
    for (my $i = 0; $i < @instance; ++$i) {
#	warn "tag=$tag inst=@{$instance[$i]}\n";
	my $inst = $instance[$i];
	pprint ($i == 0 ? $tag : "", $maxtaglen + 1, $$inst[0], -3, "", 3, $$inst[1], $maxsrcdirlen + 1, "$$inst[2]\#$$inst[3]\\n");
    }
}
print "\";\n";

print "\n";
print "#endif /* LOGTAGS_INCLUDED */\n";

# min & max functions
sub min {
    my @x = @_;
    my $min;
    foreach my $x (@x) { if (!defined($min) || $x < $min) { $min = $x } }
    return $min;
}

sub max {
    my @x = @_;
    my $max;
    foreach my $x (@x) { if (!defined($max) || $x > $max) { $max = $x } }
    return $max;
}

# padded print function
sub pprint {
    while (@_) {
	my $text = shift;
	my $width = shift;
	if (!defined($width) || $width == 0) { print $text }
	elsif ($width > 0) {
	    print $text, " " x ($width - length($text));
	} else {
	    print " " x (-$width - length($text)), $text;
	}
    }
}
