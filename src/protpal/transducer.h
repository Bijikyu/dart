#ifndef TRANSDUCER_H
#define TRANSDUCER_H
#include<iostream>
#include<map>
#include<vector>
#include<math.h>

#include "protpal/utils.h"
#include "ecfg/ecfgsexpr.h" // for array2d, alphabet classes



// Transducer class for *single* transducers.  
// There are 3 basic types of single transducers that we use (listed here with their states (actually state *types*, only in the linear gap transduer are these equivalent))
// 1. Singlet: Start - Insert - End 
// 2. Splitting: Start  - Wait - Match - End
// 3. Branch : Start - wait - insert - match - delete - end

// They're hard-coded here, but eventually we'd like to be able to import them from files, or at least provide
// some level of customizability.


class Transducer
{
 public:
  string name;
  // Vector of states.  somewhat unnecessary, if they'll always be ints , but I'll leave it just in case
  // Start state always indexed as 0, end state is always the last one.  
  vector<state> states; 
  
  // Accessor functions for state names, types, outgoing connections, trans weights.  Each makes sure the called 
  // state is in the transducer. 
  string get_state_name(state m);
  string get_state_type(state m);
  vector<state> get_state_index(string state_name);
  vector<state> get_state_type_set(string type);
  vector<state> get_outgoing(state m);

  // Access distribution over inserted characters.  Check that r is an insert state, and int is within the 
  // alphabet bounds.
  double get_emission_weight(state r, int charIndex);
  vector<double> get_emission_distribution(state r);

  // Access transition weights.  
  double get_transition_weight(state m, state mPrime);

  // Query whether m,mPrime have a transition between them.  
  bool has_transition(state m, state mPrime);

  // Character alphabet
  vector<string> alphabet;
  int alphabet_size;  
  
  //testing
  void test_transitions(void);
  
 protected:
  // vector of state names, useful for printing/debugging, etc
  vector<string> state_names;

  // Record of state connectivity.  state -> vector of states s.t. weight(q-> q') != 0
  map<state, vector<state> > outgoing; 

  // Transition weight map.  state x state -> weight
  map<vector <state>, double> transition_weight; 

  // Emission weight map.  Each insert state maps to a vector of length alphabet.size()
  // emission_weight_matrix[state][i] gives the weight of emitting character alphabet[i] from "state"
  map< state, vector<double> > emission_weight_matrix;     

  // a state type for each state
  vector<string> state_types;

};


// ***** Singlet/generating transducer ***** 

// This models the distribution over single sequences.  The basic version (used here)
// has only 3 states: start, insert, end.  Sequences are generated by looping through the insert state repeatedly.  
// Parameterized by the emission distribution from the insert state (regulates the prior over sequence composition), 
// and the insert-insert self-loop parameter, regulating the prior over sequence length.  


class SingletTrans : public Transducer
{
 public:
  // Eventually we'd like to be able to specify this transducer in a file, not have to code it:
  //  singletTrans(file);
  // For now, use a void-argument constructor that does everything for us...
  SingletTrans(void);
  SingletTrans(Alphabet&, Irrev_EM_matrix&, double insertProb=0.999);
 private:
};




// ***** Splitting/forking transducer ***** //

// This tranducer simply accepts a single input and duplicates it to its two output tapes.  For simplicity,
// we omit this trivial 'emission' distribution.  I suppose we could omit the transition weights too...

class SplittingTrans : public Transducer
{
 public:
  // Eventually we'd like to be able to specify this transducer in a file, not have to code it:
  //  singletTrans(file);
  // For now, use a void-argument constructor that does everything for us...
  SplittingTrans(void);

 private:
};



// ***** Branch transducer ***** //
// The branch transducer models the distribution of one sequence  conditional on another.  Possible transformations
// include insertions, deletions, and character substitutions.  
// Parameters (time-dependent):
//   insert rate (as insRate ) 
//   delete rate (as delRate )
//   character substitution model

//   end rate (e.g. wait-> end ) , not time-dependent (or is it?)

class BranchTrans : public Transducer
{
 public:
  float branch_length;
  // constructor.  Again, does everything for us for a basic setup/parameterization
  BranchTrans(double, Alphabet&, Irrev_EM_matrix&, double, double, double);
  BranchTrans(double branch_length_in, Alphabet& alphabet_in, Irrev_EM_matrix& rate_matrix, double ins_open_rate, double del_open_rate, double gap_extend,
	      double gap_extend2, double mixPrior, string name ); // mixture of affines
  BranchTrans(double, bool);  
  BranchTrans(void);  
  array2d<double> conditional_sub_matrix;
  double get_match_weight(state b, int incoming_character, int outgoing_character );  

};

#endif
