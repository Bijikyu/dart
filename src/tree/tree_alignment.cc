#include <sstream>
#include "tree/tree_alignment.h"
#include "util/nstring.h"
#include "seq/distmat.h"
#include "tree/nj.h"
#include "util/vector_output.h"

// autogenerated names for alignments in Stockholm databases
#define ALIGN_NAME_PREFIX "Alignment"

// tags for Insertion_database
#define ORIG_COLUMNS_TAG "COLS"
#define ROOT_TAG         "ROOT"

Stockholm_tree::Stockholm_tree (const Stockholm& stock, bool die_if_tree_missing)
{
  // check if the Stockholm alignment has a "#=GF NH" tag
  Stockholm::Tag_index_map::const_iterator nh_index_set = stock.gf_index.find (sstring (Stockholm_New_Hampshire_tag));
  if (nh_index_set != stock.gf_index.end())
    {
      // concatenate the (possibly multi-line) tree description into a string
      sstring nh;
      for_const_contents (set<int>, nh_index_set->second, i)
	nh << stock.gf_annot[*i].second;
      // create an input stream from the string; read in the tree
      istringstream tree_in (nh);
      read (tree_in);
      // create the node-to-row mapping
      node2row = vector<int> (nodes(), -1);
      for (int n = 0; n < nodes(); ++n)
	{
	  const sstring& nn = node_name[n];
	  if (nn.size())
	    {
	      const Phonebook::const_iterator r_iter = stock.row_index.find (nn);
	      if (r_iter != stock.row_index.end())
		node2row[n] = r_iter->second;
	    }
	}
    }
  else  // if we get here, then Stockholm alignment didn't have a "#=GF NH" tag
    if (die_if_tree_missing)
      THROWEXPR ("Tried to initialise a Stockholm_tree object from a Stockholm alignment that didn't include a tree");
}

Tree_alignment::Tree_alignment () : tree(), align(0), has_ref_align(false) { }

Tree_alignment::Tree_alignment (const Stockholm& stock, bool die_if_trees_missing) : tree(), align(0), has_ref_align(false)
{
  // copy alignment and tree
  set_alignment (stock);
  Stockholm_tree tree (stock, die_if_trees_missing);
  if (tree.nodes())
    {
      set_tree (tree);
      build_maps_from_names();
    }
}

Tree_alignment::Tree_alignment (const Tree_alignment& tree_align)
  : tree (tree_align.tree),
    align (tree_align.align),
    row2node (tree_align.row2node),
    node2row (tree_align.node2row),
    ref_align (tree_align.ref_align),
    has_ref_align (tree_align.has_ref_align),
    ref_pair_set (tree_align.ref_pair_set)
{
  for_const_contents (Node_profile_map, tree_align.node_profile, ns)
    {
      const Score_profile* old_prof = ((*ns).second);
      if (old_prof)
	node_profile [(*ns).first] = new Score_profile (*old_prof);
      else
	CLOGERR << "Found null pointer in Tree_alignment::node_profile during deep clone; discarding\n";
    }
  Node_profile_map::const_iterator ns;
  for (int r = 0; r < align.rows(); ++r)        // this is an ugly way of updating the Alignment's Score_profile* pointers - but it works
    if (tree_align.row2node[r] != -1)
      if ((ns = tree_align.node_profile.find (row2node[r])) != tree_align.node_profile.end())
	if (tree_align.align.prof[r] == (*ns).second)
	  align.prof[r] = node_profile[r];
}

Tree_alignment::~Tree_alignment()
{
  clear_node_profiles();
}

void Tree_alignment::tree_changed() { }
void Tree_alignment::align_changed() { }

Tree_alignment& Tree_alignment::operator= (const Tree_alignment& t)
{
  tree = t.tree;
  align = t.align;
  row2node = t.row2node;
  node2row = t.node2row;
  ref_align = t.ref_align;
  has_ref_align = t.has_ref_align;
  ref_pair_set = t.ref_pair_set;
  // deep-copy the node_profile data
  clear_node_profiles();
  for_const_contents (Node_profile_map, t.node_profile, ns)
    node_profile [(*ns).first] = new Score_profile (*((*ns).second));  // deep-copy all the Score_profile's
  // now comes a tricky bit: we've deep-copied the Node_profile_map which is a map of Nodes (ints) to Score_profile*'s
  // now we have to make sure the alignment's Score_profile*'s match the deep-copied ones in the same way as the Tree_alignment we're copying
  Node_profile_map::const_iterator ns;
  for (int r = 0; r < align.rows(); ++r) {        // this is an ugly way of updating the Alignment's Score_profile* pointers - but it works (just)
    if (row2node[r] == -1) {  // map alignment row to tree node
      align.prof[r] = (Score_profile*) 0;  // if this row isn't mapped to a tree node, set the Score_profile pointer to NULL
    } else {
      // If this node has an entry in node_profile, then the corresponding Score_profile is owned by this object and should be copied.
      // If it doesn't have an entry in node_profile, then the Score_profile is shared and should not be copied.
      if ((ns = t.node_profile.find (row2node[r])) != t.node_profile.end()) {  // check if this node's profile is owned
	if (t.align.prof[r] == (*ns).second) {  // check that this agrees with the alignment's Score_profile* for this row
	  align.prof[r] = node_profile[r];  // re-map to our copy
	} else {
	  CLOGERR << "Warning: tree and alignment have different Score_profiles\n";
	}
      }
    }
  }
  // call observer update methods
  tree_changed();
  align_changed();

  return *this;
}

void Tree_alignment::reset_maps()
{
  row2node = Phylogeny::Node_vector (align.rows(), -1);
  node2row = vector<int> (tree.nodes(), -1);
}

void Tree_alignment::clear_tree()
{
  tree.clear();
  reset_maps();
  tree_changed();
}

void Tree_alignment::clear_align()
{
  align.clear();
  reset_maps();
  align_changed();
}

void Tree_alignment::clear_node_profiles()
{
  for_contents (Node_profile_map, node_profile, ns)
    delete (*ns).second;
  node_profile.clear();
}

void Tree_alignment::clear()
{
  tree.clear();
  align.clear();
  clear_node_profiles();
  reset_maps();
  tree_changed();
  align_changed();
}

void Tree_alignment::read_PHYLIP (istream& tree_stream)
{
  tree.read (tree_stream);
  reset_maps();
  tree_changed();
}

void Tree_alignment::read_MUL (istream& align_stream, Sequence_database& db)
{
  align.read_MUL (align_stream, db);
  reset_maps();
  align_changed();
}
  
void Tree_alignment::set_tree (const PHYLIP_tree& new_tree)
{
  tree = new_tree;
  reset_maps();
  tree_changed();
}

void Tree_alignment::set_alignment (const Alignment& new_align)
{
  align = new_align;
  reset_maps();
  align_changed();
}

void Tree_alignment::update_tree_node_names_from_maps()
{
  for_iterator (Phylogeny::Node_const_iter, n, tree.leaves_begin(), tree.leaves_end())
    if (node2row[*n] != -1)
      tree.node_name[*n] = align.row_name[node2row[*n]];
    else
      {
	tree.node_name[*n].clear();
	tree.node_name[*n] << "row_" << node2row[*n]+1;
      }
  tree_changed();
}

void Tree_alignment::update_alignment_row_names_from_maps()
{
  for (int r = 0; r < align.rows(); r++)
    if (row2node[r] != -1)
      align.row_name[r] = tree.node_specifier (row2node[r]);
    else
      {
	align.row_name[r].clear();
	align.row_name[r] << "row_" << r+1;
      }
  align_changed();
}

void Tree_alignment::build_maps_from_names()
{
  reset_maps();
  set<sstring> seen;
  for (int row = 0; row < align.rows(); row++)
    {
      const sstring& this_row_name = align.row_name[row];
      if (this_row_name.size())
	{
	  if (seen.find (this_row_name) != seen.end()) THROWEXPR ("Duplicate row name '" << this_row_name << "'");
	  seen.insert (this_row_name);
	  Phylogeny::Node node = tree.specified_node (this_row_name);
	  if (node == -1)
	    THROWEXPR ("Sequence name '" << this_row_name << "' is not a valid node specifier");
	  if (node2row[node] != -1)
	    THROWEXPR ("Duplicate node specification: '" << this_row_name << "' and '" << align.row_name[node2row[node]] << "' both refer to same node (index " << node << ", canonical ID '" << tree.node_specifier(node) << "')");
	  row2node[row]  = node;
	  node2row[node] = row;
	}
      else
	{
	  sstring buf;
	  buf << "Row " << row+1 << " is unnamed and has no existing mapping to tree";
	  THROW Standard_exception (buf);
	}
    }
}

void Tree_alignment::set_node_profile (Phylogeny::Node node, Score_profile* profile)
{
  if (node_profile.find(node) != node_profile.end())
    delete node_profile[node];
  if (profile)
    node_profile[node] = profile;
  if (node2row[node] != -1)
    align.prof[node2row[node]] = profile;
}

void Tree_alignment::check_map_sizes() const
{
  if ((int) node2row.size() != tree.nodes()) THROW Standard_exception ("Tree->alignment map is the wrong size");
  if ((int) row2node.size() != align.rows()) THROW Standard_exception ("Alignment->tree map is the wrong size");
  return;
}

void Tree_alignment::make_empty_alignment()
{
  align.reset (tree.nodes());
  node2row = vector<int> (tree.nodes(), -1);
  row2node = Phylogeny::Node_vector (tree.nodes(), -1);
  for (int n = 0; n < tree.nodes(); n++) node2row[n] = row2node[n] = n;
  update_alignment_row_names_from_maps();
  align_changed();
}

void Tree_alignment::add_empty_alignment_row_for_node (Phylogeny::Node node)
{
  check_map_sizes();
  if (node2row[node] != -1)
    {
      int r = node2row[node];
      sstring ex;
      ex << "Attempt to add empty row for node " << tree.node_specifier(node) << " failed - node already represented by row #" << r;
      if (align.row_name[r].size()) ex << " (" << align.row_name[r] << ")";
      THROW Standard_exception (ex.c_str());
    }
  align.prof.push_back (0);
  align.row_name.push_back (tree.node_specifier (node));
  align.path.append_row (align.path.create_empty_row());
  row2node.push_back (node);
  node2row[node] = align.rows() - 1;
  align_changed();
}

void Tree_alignment::attach_sequences (const Sequence_database& db)
{
  for_iterator (Sequence_database::const_iterator, seq, db.begin(), db.end())
    {
      Phylogeny::Node node = tree.specified_node ((*seq).name);
      if (node < 0 || node > tree.nodes())
	CLOGERR << "Warning - sequence '" << (*seq).name << "' not found in tree\n";
      else
	if (node2row[node] < 0)
	  ERRSTR << "Sequence " << (*seq).name << " not found in alignment" << THROWSTR;
	else
	  align.prof[node2row[node]] = &(*seq).prof_sc;
    }
  for (int r = 0; r < align.rows(); ++r)
    if (row2node[r] >= 0)
      if (tree.is_leaf (row2node[r]))
	if (align.prof[r] == 0)
	  {
	    sstring e;
	    e << "No sequence for leaf node '" << tree.node_specifier (row2node[r]) << "'";
	    THROW Standard_exception (e);
	  }
  align_changed();
}

void Tree_alignment::assert_nodes_equal_rows() const
{
  check_map_sizes();
  if (align.rows() != tree.nodes())
    THROW Standard_exception ("Number of rows in alignment doesn't match number of nodes in tree");
  for (int row = 0; row < align.rows(); row++)
    {
      Phylogeny::Node node = row2node[row];
      if (node < 0 || node >= tree.nodes())
	THROWEXPR ("Invalid node associated with row #" << node+1);
      if (node2row[node] != row)
	THROWEXPR ("Node-row map inconsistent for row #" << node+1);
      Phylogeny::Node snode = tree.specified_node (align.row_name[row]);
      if (snode != node)
	THROWEXPR ("Node specifier string '" << align.row_name[row] << "' implies node #" << snode << " whereas map for row (#" << row+1 << ") says corresponding node is #" << node+1);
    }
}

void Tree_alignment::assert_leaves_equal_rows() const
{
  check_map_sizes();
  if (align.rows() != tree.leaves())
    THROW Standard_exception ("Number of rows in alignment doesn't match number of leaves in tree");
  for (int row = 0; row < align.rows(); row++)
    {
      Phylogeny::Node node = row2node[row];
      if (node < 0 || node >= tree.nodes())
	THROWEXPR ("Invalid node associated with row #" << (node+1));
      if (!tree.is_leaf (node))
	THROWEXPR ("Non-leaf node associated with row #" << (node+1));
      if (node2row[node] != row)
	THROWEXPR ("Node-row map inconsistent for row #" << (node+1));
      if (tree.specified_node (align.row_name[row]) != node)
	THROWEXPR ("Node specifier sstring doesn't match associated node for row #" <<  (node+1));
    }
}


bool Tree_alignment::nodes_equal_rows() const
{
  check_map_sizes();
  if (align.rows() != tree.nodes()) return 0;
  for (int row = 0; row < align.rows(); row++)
    {
      Phylogeny::Node node = row2node[row];
      if (node < 0 || node >= tree.nodes()) return 0;
      if (node2row[node] != row) return 0;
      if (tree.specified_node (align.row_name[row]) != node)
	return 0;
    }
  return 1;
}

bool Tree_alignment::leaves_equal_rows() const
{
  check_map_sizes();
  if (align.rows() != tree.leaves()) return 0;
  for (int row = 0; row < align.rows(); row++)
    {
      Phylogeny::Node node = row2node[row];
      if (node < 0 || node >= tree.nodes()) return 0;
      if (!tree.is_leaf (node)) return 0;
      if (node2row[node] != row) return 0;
      if (tree.specified_node (align.row_name[row]) != node)
	return 0;
    }
  return 1;
}


vector<Alignment_path::Row_pair> Tree_alignment::row_pairs() const
{
  vector<Alignment_path::Row_pair> pairs;
  for_iterator (Phylogeny::Branch_iter, b,
		tree.branches_begin (tree.root),
		tree.branches_end())
    {
      int parent_row = node2row [(*b).first];
      int child_row  = node2row [(*b).second];
      if (parent_row != -1 && child_row != -1)
	pairs.push_back (Alignment_path::Row_pair (parent_row, child_row));
    }
  return pairs;
}

Tree_alignment Tree_alignment::window (int start, int len) const
{
  // copy the whole Tree_alignment
  Tree_alignment ta (*this);
  // find sequence start & end coords
  Alignment_path::Sequence_coords seq_start = ta.align.path.create_seq_coords();
  for (int col = 0; col < start; ++col)
    ta.align.path.inc_seq_coords (seq_start, col);
  Alignment_path::Sequence_coords seq_end = seq_start;
  for (int col = start; col < start + len; ++col)
    ta.align.path.inc_seq_coords (seq_end, col);
  // trim the path
  ta.align.path.erase_columns (0, start);
  ta.align.path.erase_columns (len, ta.align.path.columns() - len);
  // trim the sequences
  for (int row = 0; row < ta.align.rows(); ++row)
    {
      const Score_profile& old_prof = *ta.align.prof[row];
      Score_profile* new_prof = new Score_profile();
      new_prof->insert (new_prof->begin(), old_prof.begin() + seq_start[row], old_prof.begin() + seq_end[row]);
      ta.set_node_profile (ta.row2node[row], new_prof);
    }
  // return
  return ta;
}

Pairwise_path Tree_alignment::subpath (Phylogeny::Node_pair pair, bool group_inserts) const
{
  Phylogeny::Node_vector node_path = tree.node_path (pair.first, pair.second, tree.parent);
  vector<int> row_path (node_path.size());
  for (int i = 0; i < (int) node_path.size(); ++i) row_path[i] = node2row[node_path[i]];
  int parent_row = row_path.front();
  int child_row = row_path.back();
  int child_inserts = 0;
  Pairwise_path result;
  for (int col = 0; col < align.columns(); ++col)
    {
      bool connected = 1;
      for (int i = 0; i < (int) row_path.size(); ++i)
	if (align.path (row_path[i], col) == 0)
	  { connected = 0; break; }
      if (connected)
	{
	  for (; child_inserts > 0; --child_inserts) result.append_column (0, 1);
	  result.append_column (1, 1);
	}
      else
	{
	  if (align.path (parent_row, col)) result.append_column (1, 0);
	  if (align.path (child_row, col))
	    {
	      if (group_inserts) ++child_inserts;
	      else result.append_column (0, 1);
	    }
	}
    }
  for (; child_inserts > 0; --child_inserts) result.append_column (0, 1);
  return result;
}


Pairwise_path Tree_alignment::realign_pair (const Phylogeny::Node_pair& pair, const Pairwise_path& ppath)
{
  if (CTAGGING(4,TREE_ALIGN))
    CL << "Changing pairwise alignment between nodes " << tree.node_specifier (pair.first) << " and " << tree.node_specifier (pair.second) << "\n";
  check_map_sizes();
  Alignment_path delta = align.path.realign_pair (Alignment_path::Row_pair (node2row[pair.first], node2row[pair.second]), ppath, row_pairs());
  align.assert_rows_fit_sequences();
  align_changed();
  return delta;
}

Pairwise_path Tree_alignment::realign_node (const Phylogeny::Node node, const Pairwise_path& align_to_new_row_map)
{
  if (CTAGGING(4,TREE_ALIGN))
    CL << "Changing alignment for node " << tree.node_specifier(node) << "\n";

  // create a subalignment containing all the rows that are directly or indirectly connected to the node being realigned,
  // and a list of the row-to-row dependencies within that subalignment
  //
  vector<int>                      connected_row_index (tree.nodes(), -1);
  vector<int>                      connected_rows;
  vector<Alignment_path::Row_pair> connected_pairs;

  connected_row_index[node] = connected_rows.size();
  connected_rows.push_back (node2row[node]);

  for_iterator (Phylogeny::Branch_iter, b,
		tree.branches_begin (node, -1, 1),
		tree.branches_end())
    if (connected_row_index[(*b).first] != -1 && node2row[(*b).second] != -1)
      {
	connected_row_index [(*b).second] = connected_rows.size();
	connected_rows.push_back (node2row[(*b).second]);
	connected_pairs.push_back (Alignment_path::Row_pair (connected_row_index[(*b).first], connected_row_index[(*b).second]));
      }
  
  Subalignment_path subpath (align.path, connected_rows, 0);

  // realign the node within the subalignment, then substitute the new subalignment for the old one
  //
  Pairwise_path nonempty_columns_map;
  nonempty_columns_map.row(0) = subpath.flag_nonempty_columns();
  nonempty_columns_map.row(1) = subpath.create_full_row();

  Pairwise_path subpath_delta = subpath.realign_row (connected_row_index[node], align_to_new_row_map, connected_pairs);
  Pairwise_path align_delta = align.path.realign_subpath (connected_rows, subpath, nonempty_columns_map * subpath_delta);

  align.assert_rows_fit_sequences();
  align_changed();
  return align_delta;
}

void Tree_alignment::show_decomposition (ostream& o, const Alignment_path::Decomposition& decomp) const
{
  for_const_contents (Alignment_path::Decomposition, decomp, npair_path)
    {
      vector<sstring> row_name (2, sstring());
      row_name[0] = "0:";
      row_name[0].append (tree.node_specifier ((*npair_path).first.first));
      row_name[1] = "1:";
      row_name[1].append (tree.node_specifier ((*npair_path).first.second));
      (*npair_path).second.show (o, align.row_name);
    }
}

void Tree_alignment::estimate_tree_by_nj (Dist_func_factory& dist_func_factory)
{
  CTAG(5,TREE_ALIGN) << "Estimating tree for the following sequences: " << align.row_name << "\n";
  // note: this function may break if alignment contains rows with names like "A::B"
  // ...i.e. internal nodes (ancestral sequences); in this case, the common ancestor of nodes A and B
  // so put the following assertion in
  if (tree.nodes() != 0)
    THROWEXPR ("Tree_alignment: tried to find tree by neighbor-joining, when there was already an existing tree in place\n");
  // create the distance function & the distance matrix
  Dist_func* dist_func = dist_func_factory.create_dist_func (align);
  Dist_matrix dist_mat (align.rows(), *dist_func);
  delete dist_func;
  // do neighbor-joining
  NJ_tree nj;
  nj.build (align.row_name, dist_mat);
  // update
  tree = nj;
  build_maps_from_names();
  tree_changed();
}

void Tree_alignment::copy_tree_to_Stockholm (Stockholm& stock) const
{
  // get string representation of tree (NH format)
  sstring tree_string;
  tree.write (tree_string, 0);

  // write into Stockholm alignment
  const sstring nh_tag (Stockholm_New_Hampshire_tag);
  Stockholm::Tag_index_map::iterator gf_iter = stock.gf_index.find (nh_tag);
  if (gf_iter == stock.gf_index.end())
    stock.add_gf_annot (nh_tag, tree_string);
  else
    {
      const int first_nh_index = *gf_iter->second.begin();
      for_contents (set<int>, gf_iter->second, nh_index)
	stock.gf_annot[*nh_index].second.clear();
      stock.gf_annot[first_nh_index].second = tree_string;
    }
}

void Tree_alignment::read_benchmark_alignment (const char* benchmark_filename, Sequence_database& db)
{
  CTAG(4,BENCHMARK) << "Reading benchmark alignment from " << benchmark_filename << "\n";
  ifstream benchmark_file (benchmark_filename);
  if (!benchmark_file) THROWEXPR ("Benchmark file '" << benchmark_filename << "' not found");
  ref_align.read_MUL (benchmark_file, db);
  ref_pair_set = ref_align.residue_pair_set();
  has_ref_align = TRUE;
}

int Tree_alignment::benchmark_residue_pair_overlap() const
{
  Alignment::Residue_pair_set my_pair_set = align.residue_pair_set();
  return Alignment::residue_pair_overlap (ref_pair_set, my_pair_set);
}

void Tree_alignment::log_benchmark_results (const char* alignment_name) const
{
  if (has_ref_align)
    {
      const int overlap = benchmark_residue_pair_overlap();
      int max_overlap = 0;
      for_const_contents (Alignment::Residue_pair_set, ref_pair_set, rps)
	max_overlap += rps->second.size();
      CTAG(9,BENCHMARK) << alignment_name << " overlaps " << overlap << " out of " << max_overlap << " residue-pairs in benchmark alignment\n";
    }
}

void Tree_alignment::write_Stockholm (ostream& out, const Alphabet& alphabet) const
{
  out << Stockholm_header;
  tree.write_Stockholm (out);
  align.write_MUL (out, alphabet, 0, true);
  out << Stockholm_footer;
}

int Tree_alignment_database::size() const
{
  return tree_align.size();
}

void Tree_alignment_database::clear()
{
  tree_align.clear();
  name.clear();
  stock_db = (Stockholm_database*) 0;
}

void Tree_alignment_database::load (const char* index_filename)
{
  clear();
  ifstream index_file (index_filename);
  if (!index_file) THROWEXPR ("Alignment index file '" << index_filename << "' not found");
  sstring s;
  while (index_file)
    {
      s.getline (index_file);
      vector<sstring> f = s.split();
      if (f.size() == 0) continue;
      if (f.size() != 3) { CLOGERR << "Warning: expect alignment database index lines to be in the format: \"<name> <tree_file> <align_file>\"\n"; continue; }

      CTAG(5,TREE_ALIGN) << "Reading alignment #" << (size() + 1) << ": '" << f[0] << "'\n";
      name.push_back (f[0]);

      tree_align_list.push_back (Tree_alignment());
      Tree_alignment& ta = *tree_align_list.rbegin();
      tree_align.push_back (&ta);

      ifstream tree_file (f[1].c_str());
      if (!tree_file) THROWEXPR ("Tree file '" << f[1] << "' not found");
      ta.read_PHYLIP (tree_file);

      ifstream align_file (f[2].c_str());
      if (!align_file) THROWEXPR ("Alignment file '" << f[2] << "' not found");
      ta.read_MUL (align_file, seq_db);

      ta.build_maps_from_names();
    }
  CTAG(6,TREE_ALIGN) << "Read " << size() << " alignments\n";
}

Tree_alignment_database::Tree_alignment_database (Sequence_database& seq_db)
  : seq_db (seq_db)
{ }

Tree_alignment_database::Tree_alignment_database (Sequence_database& seq_db, const char* index_filename)
  : seq_db (seq_db)
{
  load (index_filename);
}

void Tree_alignment_database::force_binary()
{
  for_contents (list<Tree_alignment>, tree_align_list, ta)
    ta->tree.force_binary();
}

void Tree_alignment_database::initialise_from_Stockholm_database (const Stockholm_database& stock, bool die_if_trees_missing)
{
  clear();
  stock_db = (Stockholm_database*) &stock;   // cast away const
  for_const_contents (list<Stockholm>, stock.align, align)
    {
      // create the Tree_alignment
      tree_align_list.push_back (Tree_alignment (*align, die_if_trees_missing));
      Tree_alignment& ta = *tree_align_list.rbegin();
      tree_align.push_back (&ta);
      // add name of alignment (this is the AC tag if the Stockholm alignment has it; otherwise autogenerate a name)
      sstring align_name;
      Stockholm::Tag_index_map::const_iterator ac_index_set = align->gf_index.find (sstring (Stockholm_accession_tag));
      if (ac_index_set != align->gf_index.end())
	align_name = align->gf_annot[*ac_index_set->second.begin()].second;
      else
	align_name << ALIGN_NAME_PREFIX << (int) (name.size() + 1);
      name.push_back (align_name);
    }
}

void Tree_alignment_database::estimate_missing_trees_by_nj (Dist_func_factory& dist_func_factory)
{
  for_contents (list<Tree_alignment>, tree_align_list, ta)
    if (ta->tree.nodes() == 0)
      ta->estimate_tree_by_nj (dist_func_factory);
}

Insertion_database::Insertion_database (const Stockholm& orig)
{
  // create Tree_alignment & check all rows are present (i.e. pukka ancestral reconstruction)
  Tree_alignment tree_align (orig, true);
  tree_align.assert_nodes_equal_rows();

  // get tree
  const PHYLIP_tree& tree (tree_align.tree);

  // get tree as a string
  const sstring tree_tag (Stockholm_New_Hampshire_tag);
  sstring tree_string;
  tree.write (tree_string, 0);
  tree_string.chomp();

  // set up a couple more tags
  const sstring orig_cols_tag (ORIG_COLUMNS_TAG), root_tag (ROOT_TAG);

  // set up data structures
  typedef Alignment_path::Column_index_set Column_index_set;
  list<Column_index_set> column_index_sets;
  vector<Column_index_set*> branch_inserts;
  vector<Phylogeny::Node> branch_insert_root;
  vector<Column_index_set*> current_branch_insert (tree.nodes(), (Column_index_set*) 0);
  for (int col = 0; col < orig.columns(); ++col)
    {
      // find root node of this column
      Phylogeny::Node root = -1;
      vector<bool> ungapped (tree.nodes(), false);
      for_rooted_nodes_post (tree, b)
	{
	  const Phylogeny::Node node = (*b).second;
	  if (orig.not_gap (tree_align.node2row[node], col))
	    {
	      root = node;
	      ungapped[node] = true;
	    }
	  else
	    {
	      vector<sstring> gapped_kids;
	      for_rooted_children (tree, node, c)
		if (ungapped[*c])
		  gapped_kids.push_back (tree.node_name[*c]);
	      if (gapped_kids.size() >= 2)
		THROWEXPR ("Not a strict evolutionary alignment: node " << tree.node_name[node]
			   << " is gapped, but the following child nodes are ungapped: " << gapped_kids);
	    }
	}
      if (root >= 0) // found non-gap?
	{
	  // terminate all insertions below the root
	  for_branches_pre (tree, root, tree.parent[root], b)
	    current_branch_insert[(*b).second] = (Column_index_set*) 0;
	  
	  // already in an insert state on root branch?
	  Column_index_set* current_insert = current_branch_insert[root];
	  if (!current_insert)
	    {
	      // if not, create a Column_index_set...
	      column_index_sets.push_back (Column_index_set());
	      // ...and set it to be the current insertion for this branch
	      current_insert = &(*column_index_sets.rbegin());
	      branch_inserts.push_back (current_insert);
	      branch_insert_root.push_back (root);
	      current_branch_insert[root] = current_insert;
	    }
	  // add this column to the current alignment
	  current_insert->push_back (col);
	}
    }

  // create a Stockholm_alignment for each Column_index_set
  vector<Stockholm*> column_stock (orig.columns(), (Stockholm*) 0);
  vector<Phylogeny::Node> column_root (orig.columns(), -1);
  for (int i = 0; i < (int) branch_inserts.size(); ++i)
    {
      // get Column_index_set & root node index
      Column_index_set& cis = *branch_inserts[i];
      const Phylogeny::Node root = branch_insert_root[i];

      // create Stockholm_alignment and store it
      align.push_back (Stockholm (orig.rows(), (int) cis.size()));
      Stockholm& stock = *(align.rbegin());
      align_index.push_back (&stock);

      // set tree tag
      stock.add_gf_annot (tree_tag, tree_string);

      // set a few other tags
      sstring cols_string;
      cols_string << cis;
      stock.add_gf_annot (orig_cols_tag, cols_string);
      stock.add_gf_annot (root_tag, tree.node_name[root]);

      // copy over alignment row names
      stock.row_name = orig.row_name;

      // copy over alignment columns; initialize column->Stockholm map
      for (int c = 0; c < (int) cis.size(); ++c)
	{
	  // copy the column into the alignment path
	  const int col = cis[c];
	  const vector<bool> column = orig.path.get_column (col);
	  stock.path.set_column (c, column);
	  // record pointer to Stockholm object for this column
	  column_stock[col] = &stock;
	  // record root for this column
	  column_root[col] = root;
	}

      // create Named_profiles for subtree; set Score_profile and Named_profile pointers in Alignment objects
      for_nodes_pre (tree, root, tree.parent[root], b)
	{
	  const int node = (*b).second;
	  const int row = tree_align.node2row[node];

	  if (orig.prof[row] || orig.np[row])
	    {
	      Named_profile* np = new Named_profile();
	      stock.np[row] = (np);

	      // set name
	      np->name = tree.node_name[node];

	      // copy over pointers into Alignment
	      stock.np[row] = np;
	      stock.prof[row] = &np->prof_sc;
	    }
	}
    }

  // loop over columns, adding residues to Named_profiles as appropriate
  Alignment_path::Sequence_coords coords = orig.path.create_seq_coords();
  for (int col = 0; col < orig.path.columns(); ++col)
    {
      Stockholm& stock (*column_stock[col]);
      const Phylogeny::Node root = column_root[col];

      for_nodes_pre (tree, root, tree.parent[root], b)
	{
	  const int node = (*b).second;
	  const int row = tree_align.node2row[node];
	  const int pos = coords[row];

	  // try everywhere we can think of to get info about this residue
	  bool got_char = false, got_prof = false;
	  // try orig.np
	  if (orig.np[row])
	    {
	      if (pos < (int) orig.np[row]->seq.size())
		{
		  stock.np[row]->seq.push_back (orig.np[row]->seq[pos]);
		  got_char = true;
		}

	      if (pos < (int) orig.np[row]->prof_sc.size())
		{
		  stock.np[row]->prof_sc.push_back (orig.np[row]->prof_sc[pos]);
		  got_prof = true;
		}
	    }

	  // try orig.prof
	  if (orig.prof[row] && !got_prof)
	    if (pos < (int) orig.prof[row]->size())
	      {
		stock.np[row]->prof_sc.push_back ((*orig.prof[row])[pos]);
		got_prof = true;
	      }
	}

      orig.path.inc_seq_coords (coords, col);
    }
};
