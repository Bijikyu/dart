#include "hsm/em_matrix.h"
#include "indiegram/tripletscfg.h"
#include "indiegram/tkfst.h"

// constructor
TKFST_loop_matrix::TKFST_loop_matrix()
: EM_matrix (1, SCFG_alphabet_size)
{

  // Taken from tkfstructuretree.cc.

  // Loop matrix
  // converted manually from Bjarne's
  sstring bkloop;
  bkloop << "1 4\n";
  bkloop << "A C G U\n";
  bkloop << "0.364097 0.151009 0.211881 0.273013\n";
  bkloop << "-0.749  0.164  0.322  0.263\n";
  bkloop << " 0.396 -1.565  0.242  0.927\n";
  bkloop << " 0.553  0.173 -0.964  0.239\n";
  bkloop << " 0.351  0.513  0.185 -1.050\n";
  bkloop << "0\n0\n0\n0\n";

  istringstream bkloop_in (bkloop);
  read (bkloop_in);

  diagonalize();


}

void TKFST_loop_matrix::show (ostream& o) const
{

  // equil. dist.
  o << "pi (equil. dist.)\n";
  for_const_contents (vector<double>, (*this).pi, p)
    o << (*p) << " ";
  o << "\n\n";

  // rate matrix
  o << "X (rate matrix)\n";
  (*this).X[0].write_rowcol (o); // 0 index b/c only a single class (see hsm/em_matrix_base.h)
  o << "\n\n";

  // mu (e-vals)
  o << "mu (e-vals)\n";
  for_const_contents (vector<Complex>, (*this).mu, p)
    o << (*p) << " ";
  o << "\n\n";

  // U (right e-vects)
  o << "U (right e-vects)\n";
  (*this).U.write_rowcol (o);
  o << "\n\n";

  // Uinv (left e-vects)
  o << "Uinv (left e-vects)\n";
  (*this).Uinv.write_rowcol (o);
  o << "\n\n";

}

// constructor
TKFST_stem_matrix::TKFST_stem_matrix()
: EM_matrix (1, SCFG_alphabet_size*SCFG_alphabet_size)
{
  // Taken from tkfstructuretree.cc.

  // to do: make sure that this is the same order as produced by
  // SCFG_state_typing::emit_idx()

  // Stem rate matrix converted to HSM format from Bjarne Knudsen's files on the PFOLD server website using the following Perl code:
  // perl -e '@i=qw(AA CA GA UA AC CC GC UC AG CG GG UG AU CU GU UU);%i=map(($i[$_]=>$_),0..@i-1);open K,"dbl_mat.txt";$_=<K>;@x=split;@s=map($i{$x[$_]},0..@x-1);while(<K>){($f,@r)=split;$row[$i{$f}]=join("\t",@r[@s])."\n"};close K;open K2,"dbl_p.txt";$_=<K2>;@k=split;while(<K2>){($f,@r)=split;for($i=0;$i<@r;++$i){$eqm{$f.$k[$i]}=$r[$i]}}close K2;print"1 16\n@i\n",join(" ",map($eqm{$_},@i)),"\n",@row,map("0\n",@i)'

  sstring bkstem;
  bkstem << "1 16\n";
  bkstem << "a c g u A C G U b d h v B D H V\n";  // this line changed from the autogenerated perl
  bkstem << "0.001167 0.001806 0.001058 0.177977 0.001806 0.000391 0.266974 0.000763 0.001058 0.266974 0.000406 0.049043 0.177977 0.000763 0.049043 0.002793\n";
  bkstem << "-3.607 0.420 0.589 0.617 0.420 0.000 0.132 0.019 0.589 0.132 -0.000 0.026 0.617 0.019 0.026 0.000\n";
  bkstem << "0.271 -6.070 0.068 2.861 0.024 0.079 0.008 0.010 0.003 2.135 0.000 0.401 0.124 0.008 0.057 0.020\n";
  bkstem << "0.650 0.116 -2.489 0.257 0.006 -0.000 0.734 -0.000 0.097 0.060 -0.000 0.024 0.290 0.019 0.237 -0.000\n";
  bkstem << "0.004 0.029 0.002 -1.163 0.001 0.002 0.115 0.007 0.002 0.501 0.001 0.274 0.185 0.003 0.023 0.016\n";
  bkstem << "0.271 0.024 0.003 0.124 -6.070 0.079 2.135 0.008 0.068 0.008 0.000 0.057 2.861 0.010 0.401 0.020\n";
  bkstem << "0.000 0.365 -0.000 0.799 0.365 -5.666 0.992 0.204 -0.000 0.992 0.000 0.191 0.799 0.204 0.191 0.563\n";
  bkstem << "0.001 0.000 0.003 0.077 0.014 0.001 -0.823 0.004 0.000 0.130 0.004 0.019 0.334 0.001 0.232 0.003\n";
  bkstem << "0.029 0.024 0.000 1.551 0.018 0.105 1.265 -6.126 0.026 0.473 0.000 0.324 0.688 1.105 0.044 0.473\n";
  bkstem << "0.650 0.006 0.097 0.290 0.116 -0.000 0.060 0.019 -2.489 0.734 0.000 0.237 0.257 0.000 0.024 -0.000\n";
  bkstem << "0.001 0.014 0.000 0.334 0.000 0.001 0.130 0.001 0.003 -0.823 0.004 0.232 0.077 0.004 0.019 0.003\n";
  bkstem << "-0.000 -0.000 -0.000 0.252 0.000 -0.000 2.511 -0.000 0.000 2.511 -6.933 0.631 0.252 -0.000 0.631 0.145\n";
  bkstem << "0.001 0.015 0.001 0.996 0.002 0.002 0.101 0.005 0.005 1.262 0.005 -2.554 0.084 0.001 0.037 0.038\n";
  bkstem << "0.004 0.001 0.002 0.185 0.029 0.002 0.501 0.003 0.002 0.115 0.001 0.023 -1.163 0.007 0.274 0.016\n";
  bkstem << "0.029 0.018 0.026 0.688 0.024 0.105 0.473 1.105 -0.000 1.265 0.000 0.044 1.551 -6.126 0.324 0.473\n";
  bkstem << "0.001 0.002 0.005 0.084 0.015 0.002 1.262 0.001 0.001 0.101 0.005 0.037 0.996 0.005 -2.554 0.038\n";
  bkstem << "0.000 0.013 -0.000 0.988 0.013 0.079 0.287 0.129 -0.000 0.287 0.021 0.663 0.988 0.129 0.663 -4.261\n";
  bkstem << "0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n";

  istringstream bkstem_in (bkstem);
  read (bkstem_in);

  diagonalize();

}



void TKFST_stem_matrix::show (ostream& o) const
{

  // equil. dist.
  o << "pi (equil. dist.)\n";
  for_const_contents (vector<double>, (*this).pi, p)
    o << (*p) << " ";

  // rate matrix
  o << "\nX (rate matrix)\n";
  int i = 0;
  for_const_contents (array2d<double>, (*this).X[0], p) // 0 index b/c only a single class (see hsm/em_matrix_base.h)
    {
      o << (*p) << " ";
      if (++i % (*this).X[0].xsize() == 0) { o << "\n"; }
    }

  // mu (e-vals)
  o << "mu (e-vals)\n";
  for_const_contents (vector<Complex>, (*this).mu, p)
    o << (*p) << " ";

  // U (right e-vects)
  o << "U (right e-vects)\n";
  i = 0;
  for_const_contents (array2d<Complex>, (*this).U, p)
    {
      o << (*p) << " ";
      if (++i % (*this).U.xsize() == 0) { o << "\n"; }
    }

  // Uinv (left e-vects)
  o << "Uinv (left e-vects)\n";
  i = 0;
  for_const_contents (array2d<Complex>, (*this).Uinv, p)
    {
      o << (*p) << " ";
      if (++i % (*this).Uinv.xsize() == 0) { o << "\n"; }
    }

}


// constructor
TKFST_Params::TKFST_Params (const sstring param_file)
  : lambda_1 (this->birth_rate_loop), mu_1 (this->death_rate_loop),
    lambda_2 (this->birth_rate_stem), mu_2 (this->death_rate_stem),
    loop_matrix (), stem_matrix ()
{
  read_params (param_file);
}

vector<Prob> TKFST_Params::loop_equil_dist()
{
  return loop_matrix.create_prior();
}

array2d<Prob> TKFST_Params::loop_conditional_subst_mat (double t)
{
  return loop_matrix.create_conditional_substitution_matrix (t);
}

vector<Prob> TKFST_Params::stem_equil_dist()
{
  return stem_matrix.create_prior();
}

array2d<Prob> TKFST_Params::stem_conditional_subst_mat (double t)
{
  return stem_matrix.create_conditional_substitution_matrix (t);
}


void TKFST_Params::read_params (const sstring param_file)
{

  // Stem & loop indel params (taken from tkfstructuretree.cc)
  birth_rate_loop = 0.027;
  death_rate_loop = 0.03;

  birth_rate_stem = 0.007;
  death_rate_stem = 0.01;

  stem_prob = 0.01;

  // to do (eventually): write code to allow for specification 
  // of parameters and rate matrices through the .eg file format
  // Currently they're hardcoded in as a stop-gap measure.
  //
  //  Files (reading S-expressions):
  //    dart/src/util/sexpr.{h,cc}
  //    dart/src/ecfg/ecfgsexpr.{h,cc}
  //    dart/src/handel/handalign.cc
  //    dart/src/handel/t/jc.hsm
  //    dart/src/handel/t/prot.hsm
  //
  //    Methods:
  //     (in ecfgsexpr.h)
  //    ECFG_builder::init_chain_and_alphabet(...)   [subset of xrate format]
  //    ECFG_builder::load_xgram_alphabet_and_grammars(...) [full xrate format]
  //
  //    For reading rate matrices:
  //     dart/src/tree/substitution_matrix_factory.h (base class, has the API that you need for common operations like matrix exponentiation)
  //     dart/src/tree/irrev_diag_matrix_factory.h (subclass)
  //     dart/src/hsm/em_matrix_base.h (sub-subclass)
  //

  // This should probably be modeled after EM_matrix_base (hsm/em_matrix_base.h)
  // and EM_matrix.

  // Irrev_diagonlised_matrix_factory provides a concrete implementation
  // of create_conditional_substitution_matrix(), although I need to know
  // the evecs and evals of the rate matrix, which requires diagonalization.

  // See EM_matrix::diagonalize():
  // It uses newmat's stuff to diagonalize the matrix and thereby
  // fill the evects and evals (mu, U, Uinv) stored in Irrev_diagonalised_matrix_factory.
  // After storing these, we can call Irrev_diagonalised_matrix_factory::create_conditional_substitution_matrix()
  // to get the substitution matrices which we need.

  /*
   * 1 chain file specifying the loop and stem rate matrices and 
   * corresponding equil. dist. 
   * Create temporary EM_matrix, etc. to diagonalize, etc.as appropriate.
   */

}

void TKFST_Params::dump_params (ostream& o) const
{
  o << "\nTKFST params:\n";

  o << "loop_matrix:\n";
  loop_matrix.show (o);

  o << "\nstem_matrix:\n";
  stem_matrix.show (o);

  o << "\nlambda_1 (birth_rate_loop): " << lambda_1 << "\n";
  o << "mu_1 (death_rate_loop): " << mu_1 << "\n";
  o << "lambda_2 (birth_rate_stem): " << lambda_2 << "\n";
  o << "mu_2 (death_rate_stem): " << mu_2 << "\n";
  o << "\n";
  
}

// constructor
TKFST_Triplet_Probs::TKFST_Triplet_Probs (const sstring param_file, double t, double u, double v)
  : TKFST_Params (param_file),
    depth_x (t), depth_y (u), depth_z (v),
    t (depth_x), u (depth_y), v (depth_z),
    _emit_loop (loop_equil_dist()), _emit_stem (stem_equil_dist()),
    _match_loop_x (loop_conditional_subst_mat (t)), _match_stem_x (stem_conditional_subst_mat (t)),
    _match_loop_y (loop_conditional_subst_mat (u)), _match_stem_y (stem_conditional_subst_mat (u)),
    _match_loop_z (loop_conditional_subst_mat (v)), _match_stem_z (stem_conditional_subst_mat (v))
{

  // log params
  if (CTAGGING (3, INDIEGRAM))
    {
      CL << "\nTKFST parameters and associated probabilities:\n";
      
      dump_params (CL);
      dump_trans_probs (CL);
      dump_emit_probs (CL);
    }

}

void TKFST_Triplet_Probs::dump_trans_probs (ostream& o) const
{
  o << "\nTKFST transition probability factors:\n";

  // branch lengths
  o << "depth_x (t) = " << t << "\n";
  o << "depth_y (u) = " << u << "\n";
  o << "depth_z (v) = " << v << "\n";
  o << "\n";  
      
  // corresponding (indel) probs
  o << "K1 = " << K1() << "\n";
  o << "K2 = " << K2() << "\n";
      
  o << "a1 (t) = " << a1 (t) << "\n";
  o << "b1 (t) = " << b1 (t) << "\n";
  o << "g1 (t) = " << g1 (t) << "\n";
  o << "a2 (t) = " << a2 (t) << "\n";
  o << "b2 (t) = " << b2 (t) << "\n";
  o << "g2 (t) = " << g2 (t) << "\n";

  o << "a1 (u) = " << a1 (u) << "\n";
  o << "b1 (u) = " << b1 (u) << "\n";
  o << "g1 (u) = " << g1 (u) << "\n";
  o << "a2 (u) = " << a2 (u) << "\n";
  o << "b2 (u) = " << b2 (u) << "\n";
  o << "g2 (u) = " << g2 (u) << "\n";

  o << "a1 (v) = " << a1 (v) << "\n";
  o << "b1 (v) = " << b1 (v) << "\n";
  o << "g1 (v) = " << g1 (v) << "\n";
  o << "a2 (v) = " << a2 (v) << "\n";
  o << "b2 (v) = " << b2 (v) << "\n";
  o << "g2 (v) = " << g2 (v) << "\n";

}

void TKFST_Triplet_Probs::dump_emit_probs (ostream& o) const
{
  o << "\nTKFST emission and match probability matrices:\n";

  // p1
  o << "p1 (xl)\n";
  for (int xl = 0; xl < SCFG_alphabet_size; ++xl)
    o << p1(xl) << " ";
  o << "\n\n";

  // m1_x
  o << "m1_x (wl, xl)\n";
  o << "(wl)\n";
  int i = 0;
  for (int wl = 0; wl < SCFG_alphabet_size; ++wl)
    {
      o << wl << "   ";
      for (int xl = 0; xl < SCFG_alphabet_size; ++xl)
	{
	  o << m1_x (wl, xl) << " ";
	  if (++i % SCFG_alphabet_size == 0) { o << "\n"; }
	}
    }
  o << "\n";
  // m1_y
  o << "m1_y (wl, yl)\n";
  o << "(wl)\n";
  i = 0;
  for (int wl = 0; wl < SCFG_alphabet_size; ++wl)
    {
      o << wl << "   ";
      for (int yl = 0; yl < SCFG_alphabet_size; ++yl)
	{
	  o << m1_y (wl, yl) << " ";
	  if (++i % SCFG_alphabet_size == 0) { o << "\n"; }
	}
    }
  o << "\n";


  // m1_z
  o << "m1_z (wl, zl)\n";
  o << "(wl)\n";
  i = 0;
  for (int wl = 0; wl < SCFG_alphabet_size; ++wl)
    {
      o << wl << "   ";
      for (int zl = 0; zl < SCFG_alphabet_size; ++zl)
	{
	  o << m1_z (wl, zl) << " ";
	  if (++i % SCFG_alphabet_size == 0) { o << "\n"; }
	}
    }
  o << "\n";

  // p2
  o << "p2 (xlr)\n";
  for (int xl = 0; xl < SCFG_alphabet_size; ++xl)
    for (int xr = 0; xr < SCFG_alphabet_size; ++xr)
      o << p2 (SCFG_state_typing::emit_idx (SCFG_state_typing::EmitXLR, xl, xr, 0, 0, 0, 0)) << " ";
  o << "\n\n";

  // m2_x
  o << "m2_x (wlr, xlr)\n";
  o << "(wl wr)\n";
  i = 0;
  for (int wl = 0; wl < SCFG_alphabet_size; ++wl)
    for (int wr = 0; wr < SCFG_alphabet_size; ++wr)
      {
	int wlr = SCFG_state_typing::emit_idx (SCFG_state_typing::EmitXLR, wl, wr, 0, 0, 0, 0);
	o << wl << wr << "    ";
	for (int xl = 0; xl < SCFG_alphabet_size; ++xl)
	  for (int xr = 0; xr < SCFG_alphabet_size; ++xr)
	    {
	      int xlr = SCFG_state_typing::emit_idx (SCFG_state_typing::EmitXLR, xl, xr, 0, 0, 0, 0);
	      o << m2_x (wlr, xlr) << " ";
	      if (++i % (SCFG_alphabet_size*SCFG_alphabet_size) == 0) { o << "\n"; }
	    }
      }
  o << "\n";

  // m2_y
  o << "m2_y (wlr, ylr)\n";
  o << "(wl wr)\n";
  i = 0;
  for (int wl = 0; wl < SCFG_alphabet_size; ++wl)
    for (int wr = 0; wr < SCFG_alphabet_size; ++wr)
      {
	int wlr = SCFG_state_typing::emit_idx (SCFG_state_typing::EmitXLR, wl, wr, 0, 0, 0, 0);
	o << wl << wr << "    ";
	for (int yl = 0; yl < SCFG_alphabet_size; ++yl)
	  for (int yr = 0; yr < SCFG_alphabet_size; ++yr)
	    {
	      int ylr = SCFG_state_typing::emit_idx (SCFG_state_typing::EmitYLR, 0, 0, yl, yr, 0, 0);
	      o << m2_y (wlr, ylr) << " ";
	      if (++i % (SCFG_alphabet_size*SCFG_alphabet_size) == 0) { o << "\n"; }
	    }
      }
  o << "\n";

  // m2_z
  o << "m2_z (wlr, zlr)\n";
  o << "(wl wr)\n";
  i = 0;
  for (int wl = 0; wl < SCFG_alphabet_size; ++wl)
    for (int wr = 0; wr < SCFG_alphabet_size; ++wr)
      {
	int wlr = SCFG_state_typing::emit_idx (SCFG_state_typing::EmitXLR, wl, wr, 0, 0, 0, 0);
	o << wl << wr << "    ";
	for (int zl = 0; zl < SCFG_alphabet_size; ++zl)
	  for (int zr = 0; zr < SCFG_alphabet_size; ++zr)
	    {
	      int zlr = SCFG_state_typing::emit_idx (SCFG_state_typing::EmitZLR, 0, 0, 0, 0, zl, zr);
	      o << m2_z (wlr, zlr) << " ";
	      if (++i % (SCFG_alphabet_size*SCFG_alphabet_size) == 0) { o << "\n"; }
	    }
      }
  o << "\n";

}


// constructor
TKFST_Triplet_SCFG::TKFST_Triplet_SCFG (const sstring param_file, const double t, const double u, const double v)
  : Triplet_SCFG (num_states),
    TKFST_Triplet_Probs (param_file, t, u, v)
{
  init_null_states();
  init_emit_unpaired_states();
  init_emit_paired_states();
  init_bifurc_states();
  init_transition_scores();
}

// to do: copy and paste from tkfst.tripletSCFG to fill in these functions
// Confirm that it all works correctly!
// specific checks:

void TKFST_Triplet_SCFG::init_null_states()
{
  CTAG (4, INDIEGRAM) << "state init: Null states\n";

}

void TKFST_Triplet_SCFG::init_emit_unpaired_states()
{
  CTAG (4, INDIEGRAM) << "state init: unpaired Emit states\n";

}

void TKFST_Triplet_SCFG::init_emit_paired_states()
{
  CTAG (4, INDIEGRAM) << "state init: paired Emit states\n";

}

void TKFST_Triplet_SCFG::init_bifurc_states()
{
  CTAG (4, INDIEGRAM) << "state init: Bifurc states\n";

}

void TKFST_Triplet_SCFG::init_transition_scores()
{
  CTAG (4, INDIEGRAM) << "transition_scores init\n";

}
