#include <sstream>
#include "ecfg/pfold.h"
#include "ecfg/ecfg.h"
#include "scfg/paircfg.h"

// Substitution rate matrices

// pk Copy shamelessly from Ian's TKFST_default_params, except for the four free entries
// and the diagonals in the loop matrix for which the article.grm derived rates differ
// from those on the pfold server website.

PFOLD_stem_matrix::PFOLD_stem_matrix()
  : EM_matrix (1, 16)
{
  // Stem rate matrix converted to HSM format from Bjarne Knudsen's files on the PFOLD server website using the following Perl code:
  // perl -e '@i=qw(AA CA GA UA AC CC GC UC AG CG GG UG AU CU GU UU);%i=map(($i[$_]=>$_),0..@i-1);open K,"dbl_mat.txt";$_=<K>;@x=split;@s=map($i{$x[$_]},0..@x-1);while(<K>){($f,@r)=split;$row[$i{$f}]=join("\t",@r[@s])."\n"};close K;open K2,"dbl_p.txt";$_=<K2>;@k=split;while(<K2>){($f,@r)=split;for($i=0;$i<@r;++$i){$eqm{$f.$k[$i]}=$r[$i]}}close K2;print"1 16\n@i\n",join(" ",map($eqm{$_},@i)),"\n",@row,map("0\n",@i)'
  sstring bkstem;
  bkstem << "1 16\n";
  bkstem << "a c g u A C G U b d h v B D H V\n";  // this line changed from the autogenerated perl
  bkstem << "0.001167 0.001806 0.001058 0.177977 0.001806 0.000391 0.266974 0.000763 0.001058 0.266974 0.000406 0.049043 0.177977 0.000763 0.049043 0.002793\n";
  bkstem << "-3.607 0.420 0.589 0.617 0.420 0.000 0.132 0.019 0.589 0.132 -0.000 0.026 0.617 0.019 0.026 0.000\n";
  bkstem << "0.271 -6.070 0.068 2.861 0.024 0.079 0.008 0.010 0.003 2.135 0.000 0.401 0.124 0.008 0.057 0.020\n";
  bkstem << "0.650 0.116 -2.489 0.257 0.006 -0.000 0.734 -0.000 0.097 0.060 -0.000 0.024 0.290 0.019 0.237 -0.000\n";
  bkstem << "0.004 0.029 0.002 -1.163 0.001 0.002 0.115 0.007 0.002 0.501 0.001 0.274 0.185 0.003 0.023 0.016\n";
  bkstem << "0.271 0.024 0.003 0.124 -6.070 0.079 2.135 0.008 0.068 0.008 0.000 0.057 2.861 0.010 0.401 0.020\n";
  bkstem << "0.000 0.365 -0.000 0.799 0.365 -5.666 0.992 0.204 -0.000 0.992 0.000 0.191 0.799 0.204 0.191 0.563\n";
  bkstem << "0.001 0.000 0.003 0.077 0.014 0.001 -0.823 0.004 0.000 0.130 0.004 0.019 0.334 0.001 0.232 0.003\n";
  bkstem << "0.029 0.024 0.000 1.551 0.018 0.105 1.265 -6.126 0.026 0.473 0.000 0.324 0.688 1.105 0.044 0.473\n";
  bkstem << "0.650 0.006 0.097 0.290 0.116 -0.000 0.060 0.019 -2.489 0.734 0.000 0.237 0.257 0.000 0.024 -0.000\n";
  bkstem << "0.001 0.014 0.000 0.334 0.000 0.001 0.130 0.001 0.003 -0.823 0.004 0.232 0.077 0.004 0.019 0.003\n";
  bkstem << "-0.000 -0.000 -0.000 0.252 0.000 -0.000 2.511 -0.000 0.000 2.511 -6.933 0.631 0.252 -0.000 0.631 0.145\n";
  bkstem << "0.001 0.015 0.001 0.996 0.002 0.002 0.101 0.005 0.005 1.262 0.005 -2.554 0.084 0.001 0.037 0.038\n";
  bkstem << "0.004 0.001 0.002 0.185 0.029 0.002 0.501 0.003 0.002 0.115 0.001 0.023 -1.163 0.007 0.274 0.016\n";
  bkstem << "0.029 0.018 0.026 0.688 0.024 0.105 0.473 1.105 -0.000 1.265 0.000 0.044 1.551 -6.126 0.324 0.473\n";
  bkstem << "0.001 0.002 0.005 0.084 0.015 0.002 1.262 0.001 0.001 0.101 0.005 0.037 0.996 0.005 -2.554 0.038\n";
  bkstem << "0.000 0.013 -0.000 0.988 0.013 0.079 0.287 0.129 -0.000 0.287 0.021 0.663 0.988 0.129 0.663 -4.261\n";
  bkstem << "0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n";

  istringstream bkstem_in (bkstem);
  read (bkstem_in);
}


PFOLD_loop_matrix::PFOLD_loop_matrix()
  : EM_matrix (1, 4)
{
  // Loop matrix
  // converted manually from Bjarne's
  sstring bkloop;
  bkloop << "1 4\n";
  bkloop << "A C G U\n";
  bkloop << "0.364097 0.151009 0.211881 0.273013\n";
/*bkloop << "-0.749  0.164  0.322  0.263\n";	pk these values from the pfold server
  bkloop << " 0.396 -1.565  0.242  0.927\n";
  bkloop << " 0.553  0.173 -0.964  0.239\n";
  bkloop << " 0.351  0.513  0.185 -1.050\n"; */
  bkloop << "-0.684  0.099  0.322  0.263\n";	// calculated from article.grm
  bkloop << " 0.239 -1.408  0.242  0.927\n";
  bkloop << " 0.553  0.173 -1.122  0.396\n";
  bkloop << " 0.351  0.513  0.307 -1.171\n";
  bkloop << "0\n0\n0\n0\n";

  istringstream bkloop_in (bkloop);
  read (bkloop_in);
}

PFOLD_ECFG::PFOLD_ECFG (const char* tag)
  : ECFG_scores (CFG_alphabet, pfoldTotalStates)
{
  // set state types
  state_info[pfoldS] = ECFG_null_state_info();
  state_info[pfoldF] = ECFG_emitlr_state_info (matrix_set.add_matrix (2), CFG_alphabet_size, 0);
  state_info[pfoldL] = ECFG_null_state_info();
  state_info[pfoldB] = ECFG_bifurc_state_info (pfoldL, pfoldS);
  state_info[pfoldU] = ECFG_emitl_state_info (matrix_set.add_matrix (1));

  state_info[pfoldF].annot[sstring(tag)][sstring ("<>")] = PFunc(1.);
  state_info[pfoldU].annot[sstring(tag)][sstring (".")] = PFunc(1.);

  matrix_set.chain[0].state[0] = "LNUC";
  matrix_set.chain[0].state[1] = "RNUC";

  matrix_set.chain[1].state[0] = "NUC";

  // set transition probabilities
  transition (Start, pfoldS) = Prob2Score (1);
  transition (pfoldS, pfoldB) = Prob2Score (0.868534);
  transition (pfoldS, pfoldL) = Prob2Score (0.131466);
  transition (pfoldL, pfoldU) = Prob2Score (0.894603);
  transition (pfoldL, pfoldF) = Prob2Score (0.105397);
  transition (pfoldU, End) = Prob2Score (1);
  transition (pfoldF, pfoldF) = Prob2Score (0.787640);
  transition (pfoldF, pfoldB) = Prob2Score (0.212360);

  // set substitution rate matrices
  stem_matrix() = PFOLD_stem_matrix();
  loop_matrix() = PFOLD_loop_matrix();

  // set state names
  for (int s = 0; s < states(); ++s)
    state_info[s].name << PFOLD_state_string ((PFOLD_state) s);
}

const char* PFOLD_state_enum::PFOLD_state_string (PFOLD_state state)
{
  switch (state)
  {
    case pfoldS: return "pfoldS"; break;
    case pfoldF: return "pfoldF"; break;
    case pfoldL: return "pfoldL"; break;
    case pfoldB: return "pfoldB"; break;
    case pfoldU: return "pfoldU"; break;
    default: return "[unknown]"; break;
  }
  return "UnreachableText";
}

IFOLD_ECFG::IFOLD_ECFG() : PFOLD_ECFG ("IFOLD")
{
  state_info[pfoldU].wild_gaps = false;
  state_info[pfoldF].wild_gaps = false;
}


Null_ECFG::Null_ECFG (const Alphabet& alph, bool rev)
  : ECFG_scores (alph, 1)
{
  matrix_set.add_matrix (1, rev ? Rev : Irrev);
  state_info[0] = ECFG_emitl_state_info (0);
  state_info[0].name = "S";
  matrix_set.chain[0].matrix->init_flat();
  matrix_set.chain[0].matrix->init_alphabet (alph);
  matrix_set.chain[0].state[0] = "X";

  const Prob end_prob = 1., extend_prob = 1.;  // unnormalised wrt length
  transition (Start, 0) = transition (0, 0) = Prob2Score (extend_prob);
  transition (Start, End) = transition (0, End) = Prob2Score (end_prob);

  update_rules = false;
}

Null_RNA_ECFG::Null_RNA_ECFG (bool rev)
  : Null_ECFG (RNA_alphabet, true)
{
  *matrix_set.chain[0].matrix = PFOLD_loop_matrix();
}

Null_indel_RNA_ECFG::Null_indel_RNA_ECFG() : Null_RNA_ECFG()
{
  state_info[0].wild_gaps = false;
}

Nearest_neighbor_ECFG::Nearest_neighbor_ECFG()
  : ECFG_scores (RNA_alphabet, 1),
    pair_alphabet ("Pair", alphabet.size() * alphabet.size())
{
  pair_alphabet.init_chars ("0123456789abcdef");

  state_info[0] = ECFG_state_info (1, 1, 0, 0);
  state_info[0].matrix = matrix_set.add_matrix (2, Irrev);
  state_info[0].mul[0] = 1;
  state_info[0].mul[1] = alphabet.size();
  state_info[0].name = "S";
  matrix_set.chain[0].matrix->init_alphabet (pair_alphabet);
  matrix_set.chain[0].matrix->randomise (0., 1./(double)pair_alphabet.size(), 0., 0., 0.);

  matrix_set.chain[0].state[0] = "PREVNUC";
  matrix_set.chain[0].state[1] = "EMITNUC";

  const Prob extend_prob = .999;
  transition (Start, 0) = transition (0, 0) = Prob2Score (extend_prob);
  transition (Start, End) = transition (0, End) = Prob2Score (1. - extend_prob);
}

Codon_ECFG::Codon_ECFG (bool both_strands)
  : ECFG_scores (RNA_alphabet, both_strands ? 3 : 2),
    triplet_alphabet ("Triplet", alphabet.size() * alphabet.size() * alphabet.size())
{
  triplet_alphabet.init_chars ("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@#");

  const int nullmat = matrix_set.add_matrix (1);
  matrix_set.chain[nullmat].matrix->init_alphabet (alphabet);
  matrix_set.chain[nullmat].matrix->randomise (0., 1./(double)alphabet.size(), 0., 0., 0.);
  matrix_set.chain[nullmat].state[0] = "NUC";

  const int codmat = matrix_set.add_matrix (3);
  matrix_set.chain[codmat].matrix->init_alphabet (triplet_alphabet);
  matrix_set.chain[codmat].matrix->randomise (0., 1./(double)triplet_alphabet.size(), 0., 0., 0.);
  matrix_set.chain[codmat].state[0] = "POS1";
  matrix_set.chain[codmat].state[1] = "POS2";
  matrix_set.chain[codmat].state[2] = "POS3";

  state_info[0] = ECFG_state_info (1, 0);
  state_info[0].matrix = nullmat;
  state_info[0].mul[0] = 1;
  state_info[0].name = "Null";

  state_info[1] = ECFG_state_info (3, 0);
  state_info[1].matrix = codmat;
  state_info[1].mul[0] = 1;
  state_info[1].mul[1] = alphabet.size();
  state_info[1].mul[2] = alphabet.size() * alphabet.size();
  state_info[1].annot[sstring("Codon")][sstring ("012")] = PFunc(1.);
  state_info[1].name = "Fwd";

  if (both_strands)
    {
      state_info[2] = ECFG_state_info (3, 0);
      state_info[2].matrix = codmat;
      state_info[2].mul[0] = alphabet.size() * alphabet.size();
      state_info[2].mul[1] = alphabet.size();
      state_info[2].mul[2] = 1;
      state_info[2].comp[0] = true;
      state_info[2].comp[1] = true;
      state_info[2].comp[2] = true;
      state_info[2].annot[sstring("Codon")][sstring ("210")] = PFunc(1.);
      state_info[2].name = "Rev";
    }

  transition (Start, 0) = transition (Start, 1) = transition (Start, End)
    = transition (0, 0) = transition (0, 1) = transition (0, End)
    = -Prob2Score (both_strands ? 4 : 3);
  transition (1, 0) = transition (1, 1) = transition (1, End) = -Prob2Score(3);

  if (both_strands)
    {
      transition (Start, 2) = transition (0, 2) = -Prob2Score(4);
      transition (2, 0) = transition (2, 2) = transition (2, End) = -Prob2Score(3);
    }
}
