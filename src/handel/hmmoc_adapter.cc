#include <stdio.h>
#include <unistd.h>
#include <iostream>

#include "handel/hmmoc_adapter.h"
#include "util/piper.h"
#include "util/unixenv.h"
#include "util/nullstream.h"
#include "util/xmlescape.h"

// TODO
// -- if use_centroid_band is true, use the peeled_obs rows of centroid & the centroid band width to pass centroid[] to HMMoC (at run-time, not compile-time)
// -- complain loudly if the centroid Alignment_path has any gaps larger than the centroid band width

// defs for hmmoc file

#define HMMOC_AUTHOR          "Handel-HMMoC Adapter"
#define HMMOC_MODEL_DESC      "Autogenerated from phylogenetic transducer"

#define HMMOC_MODEL_NAME      "hModel"
#define HMMOC_ALPHID          "hAlphabet"

#define HMMOC_TAPE_PREFIX     "hTape"
#define HMMOC_SEQID_PREFIX    "hSeq"
#define HMMOC_LENID_PREFIX    "hLen"
#define HMMOC_BANDID          "hBandDiameter"
#define HMMOC_CENTROID_ID     "hCentroid"
#define HMMOC_IDXID_PREFIX    "hIndex"
#define HMMOC_SEQID_PREFIX    "hSeq"
#define HMMOC_SYMID_PREFIX    "hSym"
#define HMMOC_DUMMY_PREFIX    "hDummy"

#define HMMOC_TRANSID_PREFIX  "hTrans"
#define HMMOC_PROBID_PREFIX   "hProb"

#define HMMOC_TRANS_ARRAY     "hTransParam"
#define HMMOC_EMIT_ARRAY      "hEmitParam"

#define HMMOC_STATE_PREFIX    "hState"
#define HMMOC_BLOCK_PREFIX    "hBlock"

#define HMMOC_EMPTY_EMISSION  "hNull"
#define HMMOC_EMISSION_PREFIX "hEmit"
#define HMMOC_EMISSION_PROB   "hEmitLikelihood"

#define HMMOC_INIT            "hInitialize"
#define HMMOC_FMATRIX         "hPrune"

#define HMMOC_FORWARD         "hForward"
#define HMMOC_BACKWARD        "hBackward"
#define HMMOC_VITERBI         "hViterbi"
#define HMMOC_SAMPLE          "hSample"

#define HMMOC_BACKWARD_MATRIX "pBackTable"
#define HMMOC_VITERBI_MATRIX  "pViterbiTable"

#define HMMOC_BACKWARD_PROB   "backProb"
#define HMMOC_VITERBI_PROB    "viterbiProb"

// static initializers
#define HMMOC_TMP_DIR "/tmp"
sstring HMMoC_adapter::root_directory = HMMOC_ROOT_DIR ;   // set in ../config.h by configure script
sstring HMMoC_adapter::tmp_directory = HMMOC_TMP_DIR ;
sstring HMMoC_adapter::cache_filename = "";   // formerly:  HMMOC_TMP_DIR "/" HMMOC_CPP_FILENAME_PREFIX ".cache" ;
sstring HMMoC_adapter::gcc_exec = CPLUSPLUS_COMPILER ;   // set in ../config.h by configure script
sstring HMMoC_adapter::gcc_args = "-O3 -ffast-math -finline-limit=1000 -lstdc++";
bool HMMoC_adapter::leave_debris = false;
int HMMoC_adapter::two_d_banding = 0;
int HMMoC_adapter::three_d_banding = 0;
int HMMoC_adapter::four_d_banding = 0;
int HMMoC_adapter::model_id = 0;
Compiled_executable_cache HMMoC_adapter::compiled_executable;

// constructor
HMMoC_adapter::HMMoC_adapter (Handel_movement& move)
  : move (move),
    peeled (move.peeled_composition),
    alphSize (peeled.alphabet_size),
    etree (peeled.etree),
    peeled_seq (peeled.make_seq_vec()),
    generate_forward (true),
    generate_backward (true),
    generate_sample (true),
    generate_viterbi (true),
    generate_baum_welch (true)

{
  for (int s = 0; s < (int) peeled_seq.size(); ++s)
    if (peeled_seq[s])
      {
	peeled_obs.push_back (s);
	const int nSeq = peeled_obs.size();

	peeled_seq_name.push_back (HMMOC_TAPE_PREFIX);
	peeled_seq_name.back() << nSeq;

	peeled_seq_id.push_back (HMMOC_SEQID_PREFIX);
	peeled_seq_id.back() << nSeq;

	peeled_len_id.push_back (HMMOC_LENID_PREFIX);
	peeled_len_id.back() << nSeq;

	peeled_sym_id.push_back (HMMOC_SYMID_PREFIX);
	peeled_sym_id.back() << nSeq;

	peeled_dummy_id.push_back (HMMOC_DUMMY_PREFIX);
	peeled_dummy_id.back() << nSeq;

	peeled_index_id.push_back (HMMOC_IDXID_PREFIX);
	peeled_index_id.back() << nSeq;
      }
}

HMMoC_adapter::Transition_param::Transition_param (int src, int dest)
  : pair<int,int> (src, dest)
{ }

Prob HMMoC_adapter::Transition_param::eval (HMMoC_adapter& adapter)
{
  return Score2Prob (adapter.ehmm().transition (first, second));
}

HMMoC_adapter::Emission_param::Emission_param (ENode branch_trans_index,
					       Param_type param_type,
					       int state,
					       int sym1,
					       int sym2)
  : branch_trans_index (branch_trans_index),
    param_type (param_type),
    state (state),
    sym1 (sym1),
    sym2 (sym2)
{ }

Prob HMMoC_adapter::Emission_param::eval (HMMoC_adapter& adapter)
{
  Score sc = -InfinityScore;
  Pair_transducer_scores& trans = adapter.ehmm().branch_transducer[branch_trans_index];
  switch (param_type)
    {
    case Match: sc = trans.match_val (state, sym1, sym2); break;
    case Insert: sc = trans.insert_val (state, sym1); break;
    case Delete: sc = trans.delete_val (state, sym1); break;
    default: THROWEXPR("Bad Param_type"); break;
    }
  return Score2Prob (sc);
}

// method defs
sstring HMMoC_adapter::dump_hmmoc_model_to_file (const char* hmmoc_filename_prefix,
						 const char* cpp_filename_prefix,
						 const char* cpp_header_filename_prefix,
						 const char* additional_code)
{
  sstring hmmoc_model_string;
  dump_hmmoc_model (hmmoc_model_string, cpp_filename_prefix, cpp_header_filename_prefix, additional_code);

  sstring hmmoc_xml_filename;
  hmmoc_xml_filename << hmmoc_filename_prefix << HMMOC_XML_SUFFIX;

  CTAG(5,HMMOC_ADAPTER) << "Dumping HMMoC model to file '" << hmmoc_xml_filename << "'\n";

  ofstream hmmoc_file_stream (hmmoc_xml_filename.c_str());
  if (!hmmoc_file_stream)
    THROWEXPR ("Couldn't open HMMoC file");
  hmmoc_file_stream << hmmoc_model_string;

  return hmmoc_model_string;
}

void HMMoC_adapter::dump_hmmoc_model (ostream& out, const char* cpp_filename_prefix, const char* cpp_header_filename_prefix, const char* additional_code)
{
  // clear emit_vec and trans_vec
  emit_vec.clear();
  trans_vec.clear();

  // get vars
  Transducer_SExpr_file& peeled = move.peeled_composition;
  const int alphSize = peeled.alphabet_size;
  const ETree& etree = peeled.etree;

  // hml
  out << "<hml"
      << (leave_debris ? " debug=\"yes\"" : "")
      << ">\n";

  // author
  out << "<author> " << HMMOC_AUTHOR << " </author>\n";

  // hmmoc alphabet
  out << "<alphabet id=\"" << HMMOC_ALPHID << "\">\n";
  out << ' ';
  bool long_token = false;
  for_const_contents (vector<sstring>, peeled.alphabet, c)
    {
      if (c->size() > 1)
	long_token = true;
      out << encodeForXml(*c);
    }
  if(long_token)
    CLOGERR << "Warning: Using multi-character tokens in hmmoc model dump!\n";
  out << '\n';
  out << "</alphabet>\n";

  // hmmoc "output tapes"
  for (int i = 0; i < (int) peeled_obs.size(); ++i)
    {
      out << "<output id=\"" << peeled_seq_name[i] << "\" speed=\"" << i << "\">\n";
      out << " <alphabet idref=\"" << HMMOC_ALPHID << "\"/>\n";
      out << " <identifier type=\"length\" value=\"" << peeled_len_id[i] << "\"/>\n";
      out << " <identifier type=\"sequence\" value=\"" << peeled_dummy_id[i] << "\"/>\n";
      out << " <code type=\"parameter\">int " << peeled_len_id[i] << "</code>\n";
      out << "</output>\n";
    }
   
  // initialize banding
  band_diameter = 0;  // default value of zero indicates that we do not have a valid band
  const int dim = (int) peeled_obs.size();
  const bool use_centroid = (dim == 2 && peeled.use_centroid_band);
  if (use_centroid)
    band_diameter = peeled.centroid_band_width;
  else
    {
      if (dim >= 2 && dim <= 4)
	{
	  // get upper limit of band diameter
	  band_diameter = (dim == 2 ? two_d_banding : (dim == 3 ? three_d_banding : four_d_banding));
	}

      // get alternative (length-dependent) band diameter using banding coefficients, if available
      if (peeled.has_all_banding_coefficients())
	{
	  const long coeff_band_diameter = peeled.get_band_diameter();
	  if (coeff_band_diameter < band_diameter || band_diameter == 0)
	    band_diameter = coeff_band_diameter;
	}
    }

  // do we have a valid band?
  const bool use_banding = band_diameter > 0;
  if (use_banding)
    {
      // check band diameter is not greater than max sequence length
      for_const_contents (vector<int>, peeled_obs, obs)
	band_diameter = min (band_diameter, (long) peeled_seq[*obs]->size());

      // print hmmoc stuff
      out << "<code id=\"initializeBanding\" init=\"includeBandingHeader\">\n\t";

      out << (use_centroid ? "TwoDCentroidBanding" : (dim == 2 ? "TwoDBanding" : (dim == 3 ? "ThreeDBanding" : "FourDBanding")))
	  << " bandingInstance (" << sstring::join (peeled_len_id, ", ") << ", " << HMMOC_BANDID;
      if (use_centroid)
	out << ", " << HMMOC_CENTROID_ID;
      out << ");\n</code>\n";
      out << "<banding id=\"" << HMMOC_BLOCK_PREFIX << "2Banding\">\n\t";
      out << "<code init=\"initializeBanding\">bandingInstance</code>\n\t";
      for (int n = 0; n < dim; ++n)
	out << "<code type=\"coordinate\" output=\"" << peeled_seq_name[n] << "\" value=\"" << n << "\"/>\n\t";
      out << "</banding>";

      const char* dartPath;
      dartPath = Dart_Unix::get_DARTDIR();
      out << "<code id=\"includeBandingHeader\" where=\"includes\">\n\t";
      out << "#include \"" << dartPath << "/src/handel/hmmoc_banding.h\"\n";
      out << "</code>\n";
    }

  // hmmoc hmm block
  out << "<hmm id=\"" << HMMOC_MODEL_NAME << "\">\n";

  // description
  out << "<description> " << HMMOC_MODEL_DESC << " </description>\n";

  // outputs
  out << "<outputs>\n";
  for (int i = 0; i < (int) peeled_obs.size(); ++i)
    out << " <output idref=\"" << peeled_seq_name[i] << "\"/>\n";
  out << "</outputs>\n";

  // hmmoc state cliques
  out << " <clique id=\"" << HMMOC_BLOCK_PREFIX << 1 << "\">\n";
  out << "  <state id=\"" << state2id(Grammar_state_enum::Start)
      << "\" emission=\"" << HMMOC_EMPTY_EMISSION << "\"/>"
      << " <!-- Start -->\n";
  out << " </clique>\n";

  out << " <clique id=\"" << HMMOC_BLOCK_PREFIX << 2 << "\">\n";
  if (use_banding)
    out << " <banding idref=\"" << HMMOC_BLOCK_PREFIX << "2Banding\"/>\n"; //banding in this clique if set
  for (int s = 0; s < ehmm().states(); ++s)
    out << "  <state id=\"" << state2id(s)
	<< "\" emission=\"" << hmmoc_emission_id(s) << "\"/>"
	<< " <!-- " << ehmm().get_state_name(s) << " -->\n";
  out << " </clique>\n";

  out << " <clique id=\"" << HMMOC_BLOCK_PREFIX << 3 << "\">\n";
  out << "  <state id=\"" << state2id(Grammar_state_enum::End)
      << "\" emission=\"" << HMMOC_EMPTY_EMISSION << "\"/>"
      << " <!-- End -->\n";
  out << " </clique>\n";

  out << " <graph>\n";
  out << "  <clique idref=\"" << HMMOC_BLOCK_PREFIX << 1 << "\"/>\n";
  out << "  <clique idref=\"" << HMMOC_BLOCK_PREFIX << 2 << "\"/>\n";
  out << "  <clique idref=\"" << HMMOC_BLOCK_PREFIX << 3 << "\"/>\n";
  out << " </graph>\n";

  // hmmoc emission blocks
  // empty emission
  out << " <emission id=\"" << HMMOC_EMPTY_EMISSION << "\">\n";
  out << "  <probability><code type=\"expression\"> " << 1.0 << " </code></probability>\n";
  out << " </emission>\n";

  // state emissions
  vector<int> obs_emit (peeled_obs.size());
  for (int s = 0; s < ehmm().states(); ++s)
    {
      out << " <emission id=\"" << hmmoc_emission_id(s) << "\">\n";
      // get observed emission
      for (int i = 0; i < (int) peeled_obs.size(); ++i)
	obs_emit[i] = ehmm().node_emit(s,peeled_obs[i]);   // should this be peeled_obs[i]+1 ?  Hmmmm.

      // <output> elements for observed tapes
      for (int i = 0; i < (int) peeled_obs.size(); ++i)
	if (obs_emit[i])
	  out << "  <output idref=\"" << peeled_seq_name[i] << "\"/>\n";

      // emission probability
      out << "  <probability>\n";
      out << "   <code type=\"statement\" init=\"" << HMMOC_INIT << "\">\n";
      // inputs: vectors of probabilities, representing individual positions of emitted sequence profiles for observed nodes
      for (int i = 0; i < (int) peeled_obs.size(); ++i)
	if (obs_emit[i])
	  {
	    out << "    <identifier output=\"" << peeled_seq_name[i] << "\" value=\"" << peeled_sym_id[i] << "\"/>\n";
	    out << "    <identifier type=\"position\" output=\"" << peeled_seq_name[i] << "\" value=\"" << peeled_index_id[i] << "\"/>\n";
	  }
      // output: the computed emission prob
      out << "    <identifier type=\"result\" value=\"" << HMMOC_EMISSION_PROB << "\"/>\n";

      // actual code to calculate emission prob
      out << "    <![CDATA[\n"
	  << "/* Emission " << ehmm().get_state_name(s) << " */\n";

      // Customized F_matrix fill code. For working precedents, see...
      // Transducer_scores::summarize_emission(...) in "transducer.h"
      // & hence TEmission::summarize(...)          in "inline_ehmm().h"
      //    also Transducer_peeler::prune(...)      in "multiwaydp.cc"

      // check bounds
      vector<sstring> and_terms;
      for (int i = 0; i < (int) peeled_obs.size(); ++i)
	if (obs_emit[i])
	  {
	    and_terms.push_back (sstring());
	    and_terms.back() << peeled_index_id[i]
			     << " >= 0";

	    and_terms.push_back (sstring());
	    and_terms.back() << peeled_index_id[i]
			     << " < "
			     << peeled_len_id[i];
	  }
      out << "if (" << sstring::join (and_terms, " && ") << ") {\n";

      // call summarize_emission
      ENode inserter;
      vector<ENode> deleters, matchers;
      ehmm().summarize_emission (s, inserter, deleters, matchers);

      // get branch_trans_state
      const vector<int>& branch_trans_state = ehmm().branch_trans_states[s];

      // copy emitted symbol vectors to F_matrix array
      vector<vector<int> > fmatrix_initialized (alphSize, vector<int> (etree.nodes(), (int) 0));
      for (int i = 0; i < (int) peeled_obs.size(); ++i)
	if (obs_emit[i])
	  {
	    const int n = peeled_obs[i];

	    out << "/* Initialize node #" << n << " */\n";

	    for (int sym = 0; sym < alphSize; ++sym)
	      {
		out << HMMOC_FMATRIX << '[' << n << "][" << sym << "] = ("
		    << peeled_seq_id[i] << '[' << sym << "])["
		    << peeled_index_id[i] << "];\n";
		fmatrix_initialized[sym][n]++;
	      }
	  }

      // propagate [sym-->] deleters upwards through F_matrix
      for_const_contents (vector<ENode>, deleters, n)
	{
	  const int dstate = branch_trans_state[*n];
	  const ENode p = etree.parent[*n];

	  out << "/* Propagate deletion upwards, from node #"
	      << *n
	      << " to node #"
	      << p
	      << " */\n";

	  for (int sym = 0; sym < alphSize; ++sym)
	    {
	      const int emit_idx = emit_vec.size();
	      emit_vec.push_back (Emission_param (*n, Emission_param::Delete, dstate, sym));
	      out << HMMOC_FMATRIX << '[' << p << "][" << sym << "] "
		  << (fmatrix_initialized[sym][p]++ ? "*= " : "= ")
		  << HMMOC_EMIT_ARRAY << '[' << emit_idx << ']'
		  << ";\n";
	    }
	}

      // propagate [xsym-->ysym] matchers upwards through F_matrix
      for_const_contents (vector<ENode>, matchers, n)
	{
	  const int mstate = branch_trans_state[*n];
	  const ENode p = etree.parent[*n];

	  out << "/* Propagate match upwards, from node #"
	      << *n
	      << " to node #"
	      << p
	      << " */\n";

	  for (int xsym = 0; xsym < alphSize; ++xsym)
	    {
	      vector<sstring> branch_terms;
	      for (int ysym = 0; ysym < alphSize; ++ysym)
		{
		  const int emit_idx = emit_vec.size();
		  emit_vec.push_back (Emission_param (*n, Emission_param::Match, mstate, xsym, ysym));
		  sstring branch_term;
		  branch_term << HMMOC_FMATRIX << '[' << *n << "][" << ysym << "] * "
			      << HMMOC_EMIT_ARRAY << '[' << emit_idx << ']';
		  branch_terms.push_back (branch_term);
		}
	      out << HMMOC_FMATRIX << '[' << p << "][" << xsym << "] "
		  << (fmatrix_initialized[xsym][p]++ ? "*= " : "= ")
		  << sstring::join (branch_terms, " + ")
		  << ";\n";
	    }
	}

      // terminate recursion at [-->ysym] inserter, summarizing F_matrix as sum(pruning_terms)
      const int istate = branch_trans_state[inserter];

      out << "/* Collect insertion terms at node #" << inserter << " */\n";

      vector<sstring> pruning_terms;
      for (int ysym = 0; ysym < alphSize; ++ysym)
	{
	  const int emit_idx = emit_vec.size();
	  emit_vec.push_back (Emission_param (inserter, Emission_param::Insert, istate, ysym));
	  sstring pruning_term;
	  pruning_term << HMMOC_FMATRIX << '[' << inserter << "][" << ysym << "] * "
		       << HMMOC_EMIT_ARRAY << '[' << emit_idx << ']';
	  pruning_terms.push_back (pruning_term);
	}
      out << HMMOC_EMISSION_PROB << " = " << sstring::join (pruning_terms, " + ") << ";\n";
      if (CTAGGING(-2,HMMOC_DEBUG))
	{
	  CL << "Generating verbose pruning code\n";
	  vector<sstring> emitted_peeled_index_expr;
	  for (int i = 0; i < (int) peeled_obs.size(); ++i)
	    if (obs_emit[i])
	      {
		emitted_peeled_index_expr.push_back (sstring());
		emitted_peeled_index_expr.back() << " \""
						 << peeled_seq_id[i]
						 << "[][\" << "
						 << peeled_index_id[i]
						 << " << \"]={\"";
		for (int sym = 0; sym < alphSize; ++sym)
		  emitted_peeled_index_expr.back() << (sym==0 ? " << " : " << ',' << (")
						   << peeled_seq_id[i] << '[' << sym << "])[" << peeled_index_id[i] << ']';
		emitted_peeled_index_expr.back() << " << '}'";
	      }
	  out << "cerr << \"Emission "
	      << hmmoc_emission_id(s)
	      << " (\" << "
	      << sstring::join (emitted_peeled_index_expr, " << ',' << ")
	      << " << \") is \" << "
	      << HMMOC_EMISSION_PROB
	      << " << '\\n';\n";
	}

      // if out of bounds, set emit prob to one.
      // this is a part of hmmoc I don't understand...
      // to my thinking, this code should not be called out of bounds;
      // and, if called out of bounds, it should be OK to return zero.
      // weirdly, however, this causes HMMoC to give a zero forward likelihood.
      // so, try setting out-of-bounds emission probs to 1...
      out << "} else " << HMMOC_EMISSION_PROB << " = 1;\n";

      // end of code
      out << "    ]]>\n";
      out << "   </code>\n";
      out << "  </probability>\n";
      out << " </emission>\n";
    }

  // hmmoc transitions
  vector<sstring> comment;
  out << " <transitions>\n";
  for (int s = Grammar_state_enum::Start; s < ehmm().states(); ++s)
    for (int d = Grammar_state_enum::End; d < ehmm().states(); ++d)
      if (s != Grammar_state_enum::End && d != Grammar_state_enum::Start)
	if (ehmm().transition(s,d) > -InfinityScore)
	  {
	    const int nTrans = trans_vec.size();
	    trans_vec.push_back (Transition_param (s, d));
	    comment.push_back (sstring());
	    comment.back() << ehmm().get_state_name(s)
			   << " to "
			   << ehmm().get_state_name(d);
	    out << "  <transition id=\"" << HMMOC_TRANSID_PREFIX << nTrans
		<< "\" from=\"" << state2id(s)
		<< "\" to=\"" << state2id(d)
		<< "\" probability=\"" << HMMOC_PROBID_PREFIX << nTrans
		<< "\"/>\n";
	  }
  out << " </transitions>\n";

  // /hmm
  out << "</hmm>\n";

  // probability blocks for transitions
  for (int i = 0; i < (int) trans_vec.size(); ++i)
    out << "<probability id=\"" << HMMOC_PROBID_PREFIX << i
	<< "\"><code type=\"expression\">\n "
	<< HMMOC_TRANS_ARRAY << '[' << i << ']'
	<< " /* " << comment[i]
	<< " */\n</code></probability>\n";

  // hmmoc initial <code> block
  // sequence lengths
  out << "<code id=\"" << HMMOC_INIT << "\"";
  if (additional_code)
    out << " init=\"" << HMMOC_INIT << 2 << '\"';
  out << " type=\"statement\">\n"
      << "<![CDATA[\n";
  // end of initial <code> block
  out << "]]>";
  out << "</code>\n";

  // any additional code?
  if (additional_code)
    out << "<code id=\"" << HMMOC_INIT << 2
	<< "\" where=\"declarations\" type=\"statement\">\n"
	<< "<![CDATA[\n"
	<< additional_code
	<< "]]>\n"
	<< "</code>\n";

  // hmmoc code generation directives
  out << "<codeGeneration file=\"" << cpp_filename_prefix << HMMOC_CC_SUFFIX << '\"';
  if (cpp_header_filename_prefix)
    out << " header=\"" << cpp_header_filename_prefix << HMMOC_H_SUFFIX << '\"';
  out << " realtype=\"bfloat\" language=\"C++\">\n";

  // forward algorithm
  // (actually it's backward, not forward, since hmmoc samples from the backward
  // matrix rather than the forward matrix. intuitively, hmmoc's way probably
  // makes more sense, since: (1) backward for HMMs is equivalent to Inside
  // for SCFGs; (2) sampling from the backward matrix can be done without
  // having to reverse the path afterwards, as is required when sampling from
  // forward; (3) the final score of backward is the same as the final
  // score of forward. oh well: DART samples from the forward matrix and is
  // unlikely to change in the immediate future.)
  if (generate_forward)
    {
      out << " <forward name=\"" << HMMOC_FORWARD << "\" outputTable=\"yes\">\n"
	  << "  <hmm idref=\"" << HMMOC_MODEL_NAME << "\"/>\n";
      if (use_banding)
	out << "  <code idref=\"SparseDPTable\"/>\n"; //use sparse tables if banding to conserve memory
      out << " </forward>\n";
    }
  // backward & Baum-Welch algorithm
  if (generate_backward)
    {
      out << " <backward name=\"" << HMMOC_BACKWARD << "\""
	  << (generate_forward && generate_baum_welch ? " baumWelch=\"yes\"" : "")
	  << " outputTable=\"yes\">\n"
	  << "  <hmm idref=\"" << HMMOC_MODEL_NAME << "\"/>\n";
      if (use_banding)
	out << "  <code idref=\"SparseDPTable\"/>\n";
      out << " </backward>\n";
    }

  // backward stochastic traceback algorithm
  if (generate_sample)
    {
      out << " <sample name=\"" << HMMOC_SAMPLE << "\">\n"
	  << "  <hmm idref=\"" << HMMOC_MODEL_NAME << "\"/>\n";
      if (use_banding)
	out << "  <code idref=\"SparseDPTable\"/>\n";
      out << " </sample>\n";
    }

  // Viterbi algorithm
  if (generate_viterbi)
    {
      out << " <viterbi name=\"" << HMMOC_VITERBI << "\" outputTable=\"yes\">\n"
	  << "  <hmm idref=\"" << HMMOC_MODEL_NAME << "\"/>\n";
      if (use_banding)
	out << "  <code idref=\"SparseDPTable\"/>\n";
      out << " </viterbi>\n";
    }
  // end code generation directives
  out << "</codeGeneration>\n";

  // /hml
  out << "</hml>\n";
}

sstring HMMoC_adapter::hmmoc_emission_id (int state)
{
  sstring s;
  if (state < 0)
    s << HMMOC_EMPTY_EMISSION;
  else
    s << HMMOC_EMISSION_PREFIX << Transition_scores::tm_index (state);
  return s;
}

void HMMoC_adapter::write_param (Prob param, ostream& param_stream)
{
  param_stream << param << ' ';
}

void HMMoC_adapter::write_param (long param, ostream& param_stream)
{
  param_stream << param << ' ';
}

void HMMoC_adapter::dump_hmmoc_params_to_file (const char* param_filename)
{
  // create output string
  sstring param_string;

  // write random seed
  write_param (Rnd::long_int(), param_string);

  // write sequence lengths & sequences
  for (int i = 0; i < (int) peeled_obs.size(); ++i)
    {
      const int seqLen = peeled_seq[peeled_obs[i]]->size();
      write_param ((long) seqLen, param_string);
      for (int pos = 0; pos < seqLen; ++pos)
	{
	  Symbol_score_map& ssm = (*peeled_seq[peeled_obs[i]])[pos];
	  for (int sym = 0; sym < alphSize; ++sym)
	    write_param ((ssm.find(sym) == ssm.end()
			  ? (Prob) 0
			  : Score2Prob (ssm[sym])),
			 param_string);
	}
    }

  // write centroid
  if (peeled.use_centroid_band)
    {
      if (peeled_obs.size() != 2)
	THROWEXPR ("Can't currently do centroid banding except for pairwise case");
      const int seqLen0 = peeled_seq[peeled_obs[0]]->size();
      const int seqLen1 = peeled_seq[peeled_obs[1]]->size();
      vector<int> pos0max (seqLen1 + 1, 0), pos0min (seqLen1 + 1, seqLen0);
      const Subalignment_path centroid (peeled.centroid, peeled_obs, true);
      vector<int> pos = centroid.create_seq_coords();
      for (int col = 0; col <= centroid.columns(); ++col)
	{
	  pos0min[pos[1]] = min (pos0min[pos[1]], pos[0]);
	  pos0max[pos[1]] = max (pos0max[pos[1]], pos[0]);
	  centroid.inc_seq_coords (pos, col);
	}
      pos0max[seqLen1] = max (pos0max[seqLen1], seqLen0);
      for (int pos1 = 0; pos1 <= seqLen1; ++pos1)
	{
	  const int gap_size = pos0max[pos1] - pos0min[pos1];
	  if (gap_size > band_diameter)
	    {
	      CLOGERR << "Warning: gap of size " << gap_size << " exceeds centroid band diameter!\n";
	      // strictly speaking,
	      // 1. we should abort the move if gap_size > band_diameter (possibly only if strict_banded_reversibility is set in HMMoC_adapter_options);
	      // 2. we should check the size of gaps in seq0, not just gaps in seq1 (as we currently do).
	      // instead, we cheat and widen the band (NB this violates detailed balance, so you better hope it doesn't happen too often...)
	      CLOGERR << "Bumping centroid band diameter from " << band_diameter << " to " << gap_size << "; THIS WILL VIOLATE DETAILED BALANCE\n";
	      band_diameter = gap_size;
	    }
	  write_param ((long) ((pos0min[pos1] + pos0max[pos1]) / 2), param_string);
	}
    }

  // write band diameter
  write_param (band_diameter, param_string);

  // write emit & trans params
  for (int n = 0; n < (int) emit_vec.size(); ++n)
    write_param (emit_vec[n].eval (*this), param_string);
  for (int n = 0; n < (int) trans_vec.size(); ++n)
    write_param (trans_vec[n].eval (*this), param_string);

  // write param file
  ofstream param_stream (param_filename);
  param_stream << param_string << '\n';

  // log
  if (CTAGGING(1,HMMOC_ADAPTER_PARAMS))
    CL << "Wrote the following parameters to file '" << param_filename << "':\n"
       << param_string << '\n';
}

bool HMMoC_adapter::exec_program (const char* main_code, vector<sstring>& result)
{
  // make temporary filename prefix
  sstring tmp_filename_prefix_without_pid, tmp_filename_prefix_with_pid;
  tmp_filename_prefix_without_pid << tmp_directory << '/' << HMMOC_CPP_FILENAME_PREFIX;
  tmp_filename_prefix_with_pid << tmp_filename_prefix_without_pid << getpid();
  // only append PID to temp filename if we're NOT using a cache...
  const sstring& tmp_filename_prefix (cache_filename.size() ? tmp_filename_prefix_without_pid : tmp_filename_prefix_with_pid);

  // dump model to file, with no header
  const sstring hmmoc_model_string = dump_hmmoc_model_to_file (tmp_filename_prefix.c_str(), tmp_filename_prefix.c_str(), (const char*) 0, main_code);

  // success flag
  bool success = true;

  // first update cache
  if (cache_filename.size())
    compiled_executable.load_cache();

  // compiled binary cached? if so, skip hmmoc/gcc steps
  sstring exec_filename;
  map<sstring,sstring>::const_iterator compiled_exec_iter = compiled_executable.find (hmmoc_model_string);
  if (compiled_exec_iter != compiled_executable.end())
    {
      exec_filename = compiled_exec_iter->second;
      CTAG(5,HMMOC_ADAPTER) << "Generated HMMoC model found in cache, using pre-compiled binary: " << exec_filename << '\n';
    }
  else
    {
      // create a binary filename based on model ID
      exec_filename << tmp_filename_prefix << '.' << model_id;

      // run hmmoc
      sstring hmmoc_exec, hmmoc_arg;
      hmmoc_exec << root_directory << "/bin/hmmoc";
      hmmoc_arg << tmp_filename_prefix << HMMOC_XML_SUFFIX;
      sstring hmmoc_cmd;
      hmmoc_cmd << hmmoc_exec << ' ' << hmmoc_arg;

      CTAG(5,HMMOC_ADAPTER) << "Running HMMoC as follows: " << hmmoc_cmd << '\n';

      FILE* hmmoc_pipe = popen (hmmoc_cmd.c_str(), "r");
      Stdio_filebuf hmmoc_filebuf (hmmoc_pipe, ios_base::in, DART_MAX_LINE_SIZE);
      istream hmmoc_out (&hmmoc_filebuf);
      sstring hmmoc_out_line;
      while (hmmoc_out && !hmmoc_out.eof())
	{
	  hmmoc_out_line.getline (hmmoc_out);
	  if (CTAGGING(3,HMMOC_ADAPTER HMMOC_OUTPUT))
	    CL << hmmoc_out_line;
	}
      const int hmmoc_status = pclose (hmmoc_pipe);
      if (hmmoc_status)
	success = false;

      // run C++ compiler
      sstring gcc_command_line;
      gcc_command_line << gcc_exec << ' ' << gcc_args
		       << " -I" << root_directory << "/include"
		       << ' ' << root_directory << "/include/algebras.cc"
		       << " -o " << exec_filename
		       << ' ' << tmp_filename_prefix << HMMOC_CC_SUFFIX;
      const vector<sstring> gcc_args = gcc_command_line.split();
      char* gcc_argv [gcc_args.size() + 1];
      for (int n = 0; n < (int) gcc_args.size(); ++n)
	gcc_argv[n] = (char*) gcc_args[n].c_str();  // cast away const
      gcc_argv[gcc_args.size()] = (char*) 0;

      CTAG(5,HMMOC_ADAPTER) << "Running C++ compiler as follows: " << gcc_command_line << '\n';

      pid_t gcc_pid;
      int gcc_status = 0;
      if ((gcc_pid = fork()))
	{
	  waitpid (gcc_pid, &gcc_status, 0);
	  if (gcc_status)
	    success = false;
	}
      else
	execv (gcc_argv[0], gcc_argv);

      // plunk compiled binary into cache
      if (success)
	{
	  compiled_executable[hmmoc_model_string] = exec_filename;
	  ++model_id;
	}
    }

  // proceed only if we haven't failed yet
  if (success)
    {
      // write param file
      // Always use the PID when generating the temporary filename for the param file.
      // This avoids filename clashes when running multiple processes on the same machine, using a pre-loaded compiled executable cache.
      // NB there's still a potential for clashes during the above model compilation steps, if the cache isn't fully populated;
      // this could be a problem one day. hmmm.
      // Best workaround (for now) is to ensure the cache is always fully populated by doing a "dry run" before any real sampling.
      // Longer-term, would be better to use a hash string (e.g. MD5) derived from the HMMoC XML.
      sstring param_filename;
      param_filename << tmp_filename_prefix_with_pid << HMMOC_PARAMS_SUFFIX;
      dump_hmmoc_params_to_file (param_filename.c_str());

      // open pipe to program
      sstring prog_cmd;
      prog_cmd << exec_filename << ' ' << param_filename;
      CTAG(5,HMMOC_ADAPTER) << "Running HMMoC-generated program as follows: " << prog_cmd << '\n';

      FILE* prog_pipe = popen (prog_cmd.c_str(), "r");
      Stdio_filebuf prog_filebuf (prog_pipe, ios_base::in, DART_MAX_LINE_SIZE);
      iostream prog_stream (&prog_filebuf);
      sstring param_string;

      // read results
      result.clear();
      while (prog_stream && !prog_stream.eof())
	{
	  sstring line;
	  line.getline (prog_stream);
	  result.push_back (line);
	}

      // check status
      const int prog_status = pclose (prog_pipe);
      if (prog_status)
	success = false;

      // log results
      if (CTAGGING(1,HMMOC_ADAPTER))
	{
	  CL << "Results of HMMoC-generated code:\n";
	  for_const_contents (vector<sstring>, result, res)
	    CL << *res;
	}
    }

  // clean up, clean up, everybody do their share
  // binaries are removed in destructor of Compiled_executable_cache
  if (!leave_debris)
    {
      sstring xml_filename, cc_filename, param_filename;

      xml_filename << tmp_filename_prefix << HMMOC_XML_SUFFIX; 
      cc_filename << tmp_filename_prefix << HMMOC_CC_SUFFIX; 
      param_filename << tmp_filename_prefix_with_pid << HMMOC_PARAMS_SUFFIX; 

      if (CTAGGING(5,HMMOC_ADAPTER))
	CL << "Removing the following temporary files:\n"
	   << xml_filename << '\n'
	   << cc_filename << '\n'
	   << param_filename << '\n';

      unlink (xml_filename.c_str());
      unlink (cc_filename.c_str());
      unlink (param_filename.c_str());
    }

  // return success flag
  return success;
}

Compiled_executable_cache::~Compiled_executable_cache()
{
  // save index to, or remove, all the compiled binaries
  if (size()) {
    if (HMMoC_adapter::cache_filename.size())
      save_cache();
    else if (!HMMoC_adapter::leave_debris)
      for_const_contents (Compiled_executable_cache, *this, iter)
	unlink (iter->second.c_str());
  }
}

void Compiled_executable_cache::save_cache() const
{
  if (!loaded || (loaded && size() > loaded_size))
    {
      CTAG(5,HMMOC_ADAPTER) << "HMMoC adapter: saving compiled-binary cache index to file '" << HMMoC_adapter::cache_filename << "'\n";
      ofstream cache_stream (HMMoC_adapter::cache_filename.c_str());
      cache_stream << size() << '\n';
      for_const_contents (Compiled_executable_cache, *this, xml_binary)
	{
	  sstring xml = xml_binary->first;
	  const sstring& binary = xml_binary->second;
	  // ensure xml ends in newline
	  if (xml.size() && xml.back() != '\n')
	    xml << '\n';
	  // count lines in xml
	  int lines = 0;
	  for_const_contents (sstring, xml, c)
	    if (*c == '\n')
	      ++lines;
	  // output
	  cache_stream << binary << ' ' << lines << '\n' << xml;
	}
      cache_stream << '\n';  // dummy extra newline for good measure
    }
}

void Compiled_executable_cache::load_cache()
{
  if (!loaded)
    {
      CTAG(5,HMMOC_ADAPTER) << "HMMoC adapter: attempting to load compiled-binary cache index from file '" << HMMoC_adapter::cache_filename << "'\n";
      ifstream cache_stream (HMMoC_adapter::cache_filename.c_str());
      if (cache_stream)
	{
	  int cache_size;
	  cache_stream >> cache_size;
	  for (int n = 0; n < cache_size; ++n)
	    {
	      sstring binary, xml, s;
	      int xml_lines;
	      cache_stream >> binary >> xml_lines;
	      ++xml_lines;  // hack/workaround: first line is empty (newline only), so bump up xml_lines
	      for (int l = 0; l < xml_lines; ++l)
		{
		  s.getline (cache_stream);
		  // hack/workaround: ignore first (empty) line
		  if (l == 0 && s.size() == 1 && s[0] == '\n')
		    continue;
		  xml << s;
		}
	      (*this) [xml] = binary;
	      if (CTAGGING(1,HMMOC_ADAPTER_CACHE))
		CL << "HMMoC XML for binary '" << binary << "':\n"
		   << xml
		   << "[end HMMoC XML]\n";
	    }
	  CTAG(5,HMMOC_ADAPTER) << "HMMoC adapter: loaded " << cache_size << " cache entries\n";
	  loaded_size = cache_size;
	}
      else
	CTAG(5,HMMOC_ADAPTER) << "HMMoC adapter: cache index file '" << HMMoC_adapter::cache_filename << "' not found -- soldiering on\n";
      loaded = true;
    }
}

bool HMMoC_adapter::exec_forward (Score& fwd_sc, vector<vector<int> >& sample_path, int n_samples)
{
  return exec_recursion_and_traceback (fwd_sc, sample_path, n_samples, true);
}

bool HMMoC_adapter::exec_Viterbi (Score& viterbi_sc, vector<int>& viterbi_path)
{
  vector<vector<int> > sample_path;
  const bool success = exec_recursion_and_traceback (viterbi_sc, sample_path, 1, false);
  if (success)
    viterbi_path.swap (sample_path.front());
  return success;
}

bool HMMoC_adapter::exec_recursion_and_traceback (Score& final_sc, vector<vector<int> >& sample_path, int n_samples, bool sample)
{
  // generated variable & function names
  sstring dpTable, finalProb, recurseFunction, sampleFunction;

  // sample or Viterbi?
  if (sample)
    {
      generate_backward = generate_sample = true;
      generate_forward = generate_viterbi = generate_baum_welch = false;
      dpTable = HMMOC_BACKWARD_MATRIX;
      finalProb = HMMOC_BACKWARD_PROB;
      recurseFunction = HMMOC_BACKWARD;
      sampleFunction = HMMOC_SAMPLE;
    }
  else
    {
      generate_viterbi = true;
      generate_forward = generate_backward = generate_sample = generate_baum_welch = false;
      dpTable = HMMOC_VITERBI_MATRIX;
      finalProb = HMMOC_VITERBI_PROB;
      recurseFunction << HMMOC_VITERBI << "_recurse";
      sampleFunction << HMMOC_VITERBI << "_trace";
    }

  // call dump_hmmoc_model() once, to set up emit_vec and trans_vec
  Null_ostream dummy_stream;
  dump_hmmoc_model (dummy_stream);

  // create main code block
  sstring code;

  // global variables
  // parameters
  code << "double " << HMMOC_EMIT_ARRAY << '[' << emit_vec.size() << "];\n";
  code << "double " << HMMOC_TRANS_ARRAY << '[' << trans_vec.size() << "];\n";

  // sequences
  for (int i = 0; i < (int) peeled_obs.size(); ++i)
    {
      // initialize peeled_seq_id[i] as an unallocated 2D array
      code << "double** " << peeled_seq_id[i] << ";\n";
      // dummy sequence array, to keep HMMoC happy
      code << "int* " << peeled_dummy_id[i] << ";\n";
    }

  // banding
  code << "long " << HMMOC_BANDID << ";\n";

  if (peeled.use_centroid_band)
    code << "vector<int> " << HMMOC_CENTROID_ID << ";\n";

  // double[][] F_matrix: Felsenstein scratch-space
  // (use BFloat instead of double? I guess not: shouldn't need to worry about code underflow when calculating an individual state's emit score.)
  code << "double " << HMMOC_FMATRIX
       << '[' << etree.nodes() << "][" << alphSize << "];\n";

  // main() function
  code << "#include <fstream>\n";
  code << "int main (int argc, char** argv)\n";
  code << "{\n";

  // local variables
  for (int i = 0; i < (int) peeled_obs.size(); ++i)
    {
      // sequence length
      code << "int " << peeled_len_id[i] << ";\n";
    }

  // open param file
  code << "  if (argc != 2)\n";
  code << "  {\n";
  code << "    cerr << \"Usage: \" << argv[0] << \" <param file>\\n\";\n";
  code << "    return 1;\n";
  code << "  }\n";
  code << "  std::ifstream cparam (argv[1]);\n";

  // read random seed
  code << "  long rnd_seed;\n";
  code << "  cparam >> rnd_seed;\n";
  code << "  srandom (rnd_seed);\n";

  // read sequence lengths; allocate & read sequences
  for (int i = 0; i < (int) peeled_obs.size(); ++i)
    {
      code << "  cparam >> " << peeled_len_id[i] << ";\n";
      code << "  " << peeled_dummy_id[i] << " = (int*) malloc ("
	   << peeled_len_id[i] << " * sizeof(int));\n";
      code << "  " << peeled_seq_id[i] << " = (double**) malloc ("
	   << alphSize << " * sizeof(double*));\n";
      code << "  for (int sym = 0; sym < " << alphSize << "; ++sym)\n";
      code << "    " << peeled_seq_id[i] << "[sym] = (double*) malloc ("
	   << peeled_len_id[i] << " * sizeof(double));\n";
      code << "  for (int pos = 0; pos < " << peeled_len_id[i] << "; ++pos)\n";
      code << "    {\n";
      code << "    " << peeled_dummy_id[i] << "[pos] = 0;\n";
      code << "      for (int sym = 0; sym < " << alphSize << "; ++sym)\n";
      code << "        cparam >> (" << peeled_seq_id[i] << "[sym])[pos];\n";
      code << "    }\n";
    }

  // read centroid
  if (peeled.use_centroid_band)
    code << "  " << HMMOC_CENTROID_ID << " = vector<int> (" << peeled_len_id[1] << ");\n"
	 << "  for (int cPos = 0; cPos <= " << peeled_len_id[1] << "; ++cPos)\n"
	 << "    cparam >> " << HMMOC_CENTROID_ID << "[cPos];\n";

  // read band diameter
  code << "  cparam >> " << HMMOC_BANDID << ";\n";

  // read emit & trans params
  code << "  for (int n = 0; n < " << emit_vec.size() << "; ++n)\n";
  code << "    cparam >> " << HMMOC_EMIT_ARRAY << "[n];\n";
  code << "  for (int n = 0; n < " << trans_vec.size() << "; ++n)\n";
  code << "    cparam >> " << HMMOC_TRANS_ARRAY << "[n];\n";

  // prepare args for HMMoC DP functions
  // HMMoC seems to sort these args by type, and then alphabetically (weird)
  // here we assume this isn't a problem, because:
  //  (a) we only have one type of arg per sequence,
  //  (b) there are <10 sequences, so args should be sorted by default
  // (i.e. no problems with "10" appearing before "2" in alphabetic sort)
  vector<sstring> dp_args;
  for (int i = 0; i < (int) peeled_obs.size(); ++i)
    dp_args.push_back (peeled_len_id[i]);
  const sstring dp_arg_string = sstring::join (dp_args, ", ");

  // build DP matrix & print final score
  code << "  hModelDPTable* " << dpTable << ";\n";
  code << "  const bfloat " << finalProb << " = " << recurseFunction
       << " (&" << dpTable << ", " << dp_arg_string << ");\n";
  code << "  cout << (int) (0.5 + " << DartScore2BitsRatio << " * log(" << finalProb << ") / log(2)) << '\\n';\n";

  // sample tracebacks
  code << "  for (int n = 0; n < " << n_samples << "; ++n)\n";
  code << "    {\n";
  code << "      Path& path = " << sampleFunction
       << " (" << dpTable << ", " << dp_arg_string << ");\n";
  code << "      if (path.size())\n";
  code << "	 {\n";
  code << "	   cout << " << dpTable << "->getStateId (path.fromState(0));\n";
  code << "	   for (int t = 0; t < path.size(); ++t)\n";
  code << "	     cout << ' ' << " << dpTable << "->getStateId (path.toState(t));\n";
  code << "	   cout << '\\n';\n";

  if (CTAGGING(-2,HMMOC_DEBUG))
    {
      CL << "Generating sampled-path score calculation verbose-debug code\n";
      code << "double p = 1;\n"
	   << "for (int t = 0; t < path.size(); ++t)\n"
	   << " p *= path.prob(t);\n"
	   << "cerr << \"Path: \" << " << dpTable << "->getStateId (path.fromState(0));\n"
	   << "for (int t = 0; t < path.size(); ++t)\n"
	   << " cerr << ' ' << " << dpTable << "->getStateId (path.toState(t));\n"
	   << "cerr << \" Bits: \" << -log(p)/log(2) << '\\n';\n";
    }
  code << "	 }\n";
  code << "    }\n";

  if (CTAGGING(-2,HMMOC_DEBUG))
    {
      CL << "Generating DP matrix verbose-debug code\n";
      code << "cerr << \"Coords State:Bits\\n\";\n";
      for (int i = 0; i < (int) peeled_obs.size(); ++i)
	code << "for (int i" << i
	     << " = 0; i" << i
	     << " <= " << peeled_seq[peeled_obs[i]]->size()
	     << "; ++i" << i
	     << ") {\n";
      code << "cerr << '['";
      for (int i = 0; i < (int) peeled_obs.size(); ++i)
	code << (i==0 ? "" : " << ','") << " << i" << i;
      code << " << ']'";

      for (int s = 0; s < ehmm().states(); ++s)
	{
	  code << " << \" " << state2id(s)
	       << ":\" << -log(" << dpTable << "->getProb(" << dpTable << "->getId(string(\""
	       << state2id(s)
	       << "\"))";
	  for (int i = 0; i < (int) peeled_obs.size(); ++i)
	    code << ",i" << i;
	  code << "))/log(2)";
	}
      code << " << '\\n';\n";
      for (int i = 0; i < (int) peeled_obs.size(); ++i)
	code << "}\n";
    }

  // free DP matrix
  code << "  delete " << dpTable << ";\n";

  // free sequences
  for (int i = 0; i < (int) peeled_obs.size(); ++i)
    {
      code << "  for (int sym = 0; sym < " << alphSize << "; ++sym)\n";
      code << "    free (" << peeled_seq_id[i] << "[sym]);\n";
      code << "  free (" << peeled_seq_id[i] << ");\n";
      code << "  free (" << peeled_dummy_id[i] << ");\n";
    }

  // return
  code << "  return 0;\n";
  code << "}\n";
  code << "\n";

  // run
  vector<sstring> result;
  bool success = exec_program (code.c_str(), result);
  if (success && (int) result.size() >= n_samples + 1)
    {
      final_sc = result[0].to_int();
      sample_path.clear();
      for (int n = 0; n < n_samples; ++n)
	{
	  vector<int> path;
	  const vector<sstring> path_states = result[n+1].split();
	  for_const_contents (vector<sstring>, path_states, ps)
	    path.push_back (id2state(*ps));
	  sample_path.push_back (path);
	}
    }
  else
    success = false;

  // return
  return success;
}

sstring HMMoC_adapter::state2id (int acyclic_state_index)
{
  sstring hmmoc_id;
  hmmoc_id << HMMOC_STATE_PREFIX << Transition_scores::tm_index (acyclic_state_index);
  return hmmoc_id;
}

int HMMoC_adapter::id2state (const sstring& hmmoc_id)
{
  int acyclic_state_index = Grammar_state_enum::UndefinedState;
  sstring state_id_regexp_str;
  state_id_regexp_str << '^' << HMMOC_STATE_PREFIX << "(0|[123456789][0123456789]*)$";
  Regexp state_id_regexp (state_id_regexp_str.c_str());
  if (state_id_regexp.Match (hmmoc_id.c_str()))
    acyclic_state_index = Transition_scores::tm_inverse (state_id_regexp[1].to_int());
  return acyclic_state_index;
}

EHMM_transducer_scores& HMMoC_adapter::ehmm()
{
  return move.elim_ehmm_scores;
}
