enum AminoAcid { a,r,n,d,c,q,e,g,h,i,l,k,m,f,p,s,t,w,y,v };
table<AminoAcid,table<AminoAcid,int>> match_score;
int gap;
int ext;
sequence<AminoAcid> query;
sequence<AminoAcid> target;
parse SW_parse {
    terminal(query) Q;
    terminal(target) T;
    nonterminal MATCH, INSERT, DELETE;
 QUERYSTART:    start -> Q start;
 TARGETSTART:   start -> T start;
 START2MATCH:   start -> Q T MATCH { exp (match_score[$1][$2]) };
 MATCH2MATCH:   MATCH -> Q T MATCH { exp (match_score[$1][$2]) };
 INSERT2MATCH:  INSERT -> Q T MATCH { exp (match_score[$1][$2]) };
 DELETE2MATCH:  DELETE -> Q T MATCH { exp (match_score[$1][$2]) };
 START2INSERT:  start -> T INSERT { exp (gap) };
 MATCH2INSERT:  MATCH -> T INSERT { exp (gap) };
 INSERT2INSERT: INSERT -> T INSERT { exp (ext) };
 DELETE2INSERT: DELETE -> T INSERT { exp (gap) };
 START2DELETE:  start -> Q DELETE { exp (gap) };
 MATCH2DELETE:  MATCH -> Q DELETE { exp (gap) };
 INSERT2DELETE: INSERT -> Q DELETE { exp (gap) };
 DELETE2DELETE: DELETE -> Q DELETE { exp (ext) };
 START2END:     start -> end;
 MATCH2END:     MATCH -> end;
 INSERT2END:    INSERT -> end;
 DELETE2END:    DELETE -> end;
 QUERYEND:      end -> Q end;
 TARGETEND:     end -> T end;
};
SW_parse SmithWaterman;
SmithWaterman = argmax (SW_parse p) { calc(p) };
