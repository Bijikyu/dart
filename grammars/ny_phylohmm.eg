;; Clone of PHASTCONS-style phylo-HMM, to illustrate xrate macro functionality
;; To see how the macros expand, type the following:

;;  echo | xrate -g dart/grammars/conservation_phylohmm.eg -t expanded.eg
;;  more expanded.eg

(&scheme
 (load-from-path "xrate-stdlib.scm")
 xrate-dna-alphabet)


;; Begin by defining the number of rate classes and the gamma hyperparameters
(&define CLASSES 10)
(&define ALPHA 1)
(&define BETA 1)

;; Scheme stuff
(&scheme-discard
 ;; Import Scheme list library
 (use-modules (srfi srfi-1))
 ;; Define rate classes
 ;; Uses the DART-provided Scheme function (discrete-gamma-medians alpha beta K)
 (define RATES (discrete-gamma-medians ALPHA BETA CLASSES)))

;; Now comes the grammar
(grammar
 (name NielsenYangPhyloHMM)
 (parametric)

 ;; Probability parameters
 ;; Probability of staying in the same rate class, or leaving
 (const-pgroup
  ;; Uncomment to fit each column separately (no autocorrelation)
  ;; ((stayProb (&/ 1 CLASSES)) (leaveProb (&- 1 (&/ 1 CLASSES)))))
  ;; Uncomment to introduce some autocorrelation
  ((stayProb .5) (leaveProb .5)))

 ;; Codon probability parameters
 (&scheme (xrate-NY-prob-params 'pi_))

 ;; Rate parameters
 (const-rate
  (omega_global 1)  ;; global synonymous/nonsynonymous ratio
  (kappa 1))  ;; transition/transversion ratio

 (rate
  (R_global 1))  ;; global rate scaling.... non-const, so can find best scale via training

 ;; Main loop over classes
 (&foreach-integer
  CLASS
  (1 CLASSES)

  ;; Rate multiplier for this class
  ;; Uncomment to have the phylo-HMM states be scaled by global rate
  ;; (const-rate ((&. R_ CLASS) (&scheme (list-ref RATES (&- CLASS 1)))))
  (const-rate ((&. R_ CLASS) 1))

  ;; Omega multiplier for this class
  ;; Uncomment to fix the ka/ks for all phylo-HMM states
  ;; (const-rate ((&. omega_ CLASS) 1))
  (const-rate ((&. omega_ CLASS) (&scheme (list-ref RATES (&- CLASS 1)))))

  ;; Markov chain for codon substitution
  (&scheme
   (xrate-NY-codon-chain '((&. NY1_ CLASS) (&. NY2_ CLASS) (&. NY3_ CLASS)) 'pi_ 'kappa 1 (quote ((&. R_ CLASS) (&. omega_ CLASS) omega_global R_global)) (quote ((&. R_ CLASS) R_global))))

  ;; transformation rules for state S{CLASS}

  (transform
   (from (START))
   (to ((&. S CLASS)))
   (prob (&/ 1 CLASSES)))

  (transform
   (from ((&. S CLASS)))
   (to ((&. NY1_ CLASS) (&. NY2_ CLASS) (&. NY3_ CLASS) (&. S CLASS *)))

   ;; OMEGA_BIN row is annotated '1' (lowest omega), '2', '3' ...
   (annotate
    (row OMEGA_BIN)
    (column (&. NY1_ CLASS))
    (label (&chr (&+ CLASS (&ord 0) -1))))

   (annotate
    (row OMEGA_BIN)
    (column (&. NY2_ CLASS))
    (label (&chr (&+ CLASS (&ord 0) -1))))

   (annotate
    (row OMEGA_BIN)
    (column (&. NY3_ CLASS))
    (label (&chr (&+ CLASS (&ord 0) -1))))

   ;; FRAME row is annotated '1', '2', '3'
   (annotate
    (row FRAME)
    (column (&. NY1_ CLASS))
    (label 1))

   (annotate
    (row FRAME)
    (column (&. NY2_ CLASS))
    (label 2))

   (annotate
    (row FRAME)
    (column (&. NY3_ CLASS))
    (label 3)))

  (transform
   (from ((&. S CLASS *)))
   (to ()) (prob 1))

  ;; transitions
  (&foreach-integer
   DEST_CLASS
   (1 CLASSES)
   (transform
    (from ((&. S CLASS *)))
    (to ((&. S DEST_CLASS)))
    (prob (&?
	   (&= CLASS DEST_CLASS)
	   (stayProb)
	   (leaveProb / (&- CLASSES 1))))))

  ) ;; end main loop over classes

 ;; Add a START->END transition, so empty alignments don't have zero likelihood
 (transform
  (from (START))
  (to ()))

 )  ;; end grammar

